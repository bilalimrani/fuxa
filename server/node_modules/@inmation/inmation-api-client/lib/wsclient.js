'use strict';

const EventEmitter = require('events').EventEmitter;

const { WS } = require('./environment.js');
const { WSConnectionInfo } = require('./model');
const { AuthenticateRPC, CloseRPC, ExecFunctionRPC, MassRPC, ReadHistoricalDataRPC, ReadHistoricalDataAtTimeRPC,
    ReadRawHistoricalDataRPC, ReadRPC, RunScriptRPC, SubscribeRPC, WriteRPC } = require('./rpc-model');

const invokeCallback = (cb, ...args) => {
    if (typeof (cb) === 'function') {
        return cb(...args);
    }
}

const RECONNECT_DELAY_TIME = 100;
const RECONNECT_DELAY_TIME_AFTER_ERROR = 5000;
const RECONNECT_DELAY_TIME_AFTER_SERVER_DOWN = 10000;

let instanceID = 0;

const isNumber = (arg) => {
    return typeof arg === 'number';
}

class WSClient extends EventEmitter {

    /**
     * Set up the WebSocket client.
     * @param {Object} [options] Can consist of {
     *   "debug": "<bool>", // Write debug log to console
     *
     */
    constructor(options) {
        super();

        options = options || {}
        this._debug = options.debug === true

        this._reconnectDelayTime = RECONNECT_DELAY_TIME;
        this._ws = null;
        instanceID += 1;
        this._instanceID = instanceID;
        // Connection Info contains e.g. sessionid, state and whether the authentication went well.
        this._connectionInfo = new WSConnectionInfo();
        this._connectionInfo.instanceID = instanceID;
        this._subscriptionItems = {};

        this._emitConnectionInfo = (readyState) => {
            // Only emit when Connection Info is actually changed.
            if (this._connectionInfo.setReadyState(readyState)) {
                this.emit(WSClient.CONNECTIONCHANGED, this._connectionInfo);
            }
        }
    }

    _log(msg) {
        if (this._debug) {
            let now = new Date();
            now = now.toISOString();
            console.log(`${now}, ${this._instanceID}, ${msg}`);
        }
    }

    _subscribeReqIDCallback(reqid, cb) {
        if (typeof (cb) === 'function') {
            this.once(reqid, (...args) => {
                cb(...args);
            });
        }
    }

    /**
     * Authentication request to the WebSocket server.
     *
     * @param {Object} options With authorization options.
     * @param {Function} cb Callback.
     * @returns {void}
     */
    authenticate(options, cb) {
        options = options || {}
        if (options.usr && options.pwd) {
            options.auth = {
                username: options.usr,
                password: options.pwd
            }
        }
        if ((typeof (options.auth) !== 'object') && (typeof (options.authorization) !== 'string')) {
            return invokeCallback(cb, new Error('No authentication options specified.'));
        }
        // Store for reconnection.
        this.options.auth = options.auth
        const msg = new AuthenticateRPC(options);
        this._subscribeReqIDCallback(msg.reqid, cb);
        this.send(msg, (err) => {
            if (err) return invokeCallback(cb, err);
        });
    }

    /**
     * Close connection to the WebSocket server.
     *
     * @param {Number} [code] Status code explaining why the connection is closing.
     * @param {String} [reason] Reason of closing.
     * @returns {void}
     */
    close(code, reason) {
        clearTimeout(this._reconnectTimer);
        this._reconnectTimer = null;
        this._autoReconnect = false;
        const ws = this._ws;
        if (ws) {
            this.send(new CloseRPC());
            this._log(`Closing connection with code ${code} and reason ${reason} from ${this.url}`);
            ws.close(code, reason);
            this._emitConnectionInfo(this._ws.readyState);
        }
    }

    /**
     * Connect to the WebSocket server.
     *
     * @param {String} url URL of the WebSocket.
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "<string>", // Username (deprecated)
     *   "pwd": "<string>", // Password (deprecated)

     *   "auth": "Object" // Authorization options
     *   "tim": 5000, // handshakeTimeout (obsolete, use wsOptions)
     *   "wsOptions?": {} // see WebSocket.ClientOptions (https://github.com/websockets/ws)
     * }
     * @returns {void}
     */
    connect(url, cb, options) {
        const emptyCallback = () => false;
        const _cb = (typeof (cb) === 'function') ? cb : emptyCallback;

        // Store connect options for access via authenticate method.
        options = options || {}
        this.options = options;

        // Remove old listeners.
        if (this._ws && typeof (this._ws.removeAllListeners) === 'function') {
            this._ws.removeAllListeners();
        }
        this.close(1000, "Going to reconnect.");

        if (typeof (url) !== 'string')
            return _cb(Error('WebSocket URL is not specified in configuration.'));
        this.url = url;

        // Avoid adding the same listener when doing a reconnect.
        if (this.listenerCount(WSClient.CONNECTION) === 0) {
            this.once(WSClient.CONNECTION, (err, connectionInfo) => {
                if (err) return _cb(err);
                if (options.auth || (options.usr && options.pwd) || typeof (options.authorization) === 'string') {
                    // Perform authentication when authorization or (username and password) are supplied.
                    this.authenticate(options, _cb);
                }
                else {
                    _cb(err, connectionInfo);
                }
            });
        }

        const reconnect = () => {
            if (this._ws && typeof (this._ws.removeAllListeners) === 'function') {
                this._ws.removeAllListeners();
                this._log(`Removed all listeners`);
            }
            if (this._autoReconnect === false) {
                this._log(`Client has closed the connection.`);
                return;
            }
            if (this._reconnectTimer) {
                this._log(`Reconnect is suppressed because reconnect timer is running.`);
                return;
            }
            const that = this
            this._log(`Reconnect in ${this._reconnectDelayTime} milliseconds to ${that.url}.`);
            this._reconnectTimer = setTimeout(function () {
                that._log(`Reconnecting to ${that.url}...`);
                that.connect(that.url, null, that.options);
            }, this._reconnectDelayTime);
        }

        let ws = null;
        this._ws = null;
        this._log(`Connecting to ${this.url}`);
        if (WS.length < 3) {
            // Browsers build-in WebSocket.
            ws = new WS(this.url);
        }
        else {
            const wsClientOptions = options.wsOptions || {}
            if (isNumber(options.tim) && !isNumber(wsClientOptions.handshakeTimeout)) {
                wsClientOptions.handshakeTimeout = options.tim;
            }
            ws = new WS(this.url, wsClientOptions);
        }
        this._autoReconnect = true;
        this._ws = ws;
        this._log(`WebSocket created`);
        this._emitConnectionInfo(ws.readyState);

        ws.onerror = (err) => {
            this._log('WebSocket onerror: ' + err.message);
            if (err && err.message && err.message.includes('ECONNREFUSED')) {
                this._reconnectDelayTime = RECONNECT_DELAY_TIME_AFTER_ERROR;
                reconnect();
            }
            this.emit(WSClient.ERROR, err);
        };

        ws.onopen = (event) => {
            this._log(`WebSocket onopen`);
            // Restore reconnect delay time.
            this._reconnectDelayTime = RECONNECT_DELAY_TIME;
            this._emitConnectionInfo(event.target.readyState);
        };

        ws.onclose = (event) => {
            const code = event.code
            const msg = `code: ${code}, reason: '${event.reason}'.`
            this._log(`WebSocket onclose, ${msg}`);
            const targetWS = event.target;
            this._emitConnectionInfo(targetWS.readyState);
            // Emit as error if close was not initiated by caller.
            if (this._autoReconnect) {
                const err = new Error(`WebSocket closed with ${msg}`);
                this.emit(WSClient.ERROR, err);
            }
            if (code === 1001) {
                // Web API server is going down.
                this._reconnectDelayTime = RECONNECT_DELAY_TIME_AFTER_SERVER_DOWN;
            }
            else if (code === 1008) {
                // Authentication failed.
                this._reconnectDelayTime = RECONNECT_DELAY_TIME_AFTER_ERROR;
            }
            else if (code === 1011) {
                // Web API Server is terminating the connection so that a reconnect and a re-authorization will be performed.
                this._reconnectDelayTime = RECONNECT_DELAY_TIME_AFTER_ERROR;
            }
            else {
                this._reconnectDelayTime = RECONNECT_DELAY_TIME;
            }
            reconnect();
        };

        ws.onmessage = (event) => {
            this._log(`OnMessage: ${event.data}`);
            let message = {
                code: 0,
                type: 'UNKNOWN'
            };
            try {
                message = JSON.parse(event.data);
            } catch (e) {
                message.error = {
                    msg: e.message
                };
            }

            let err = null;
            const code = message.code;
            const success = (code >= 200 && code <= 299);
            if (success) {
                this._reconnectDelayTime = RECONNECT_DELAY_TIME;
            }
            else {
                let errMsg = `Failed with code ${code}`;
                const appendErrMsg = (error) => {
                    if (typeof (error) === 'object' && typeof (error.msg) === 'string') {
                        errMsg = `${errMsg}, ${error.msg}`
                    }
                }
                if (typeof (message) === 'object') {
                    if (Array.isArray(message.error)) {
                        for (const errorItem of message.error) {
                            appendErrMsg(errorItem)
                        }
                    }
                    else {
                        appendErrMsg(message.error)
                    }
                    if (Array.isArray(message.data)) {
                        // Read error from each Context response.
                        for (const vqtRes of message.data) {
                            appendErrMsg(vqtRes.error)
                        }
                    }

                }
                err = new Error(errMsg);
            }

            // Store or wipe Connection Info.
            let connectionChanged = false;
            if (message.type === WSClient.CONNECTION || message.type === WSClient.AUTHENTICATION) {
                connectionChanged = this._connectionInfo.processInfo(message.data, event.target.readyState);
                // Reset message.data to be send around.
                message.data = this._connectionInfo;
            }

            // Emit Error only when root error is present in message.
            if (err && message.error) {
                if (message.type === WSClient.AUTHENTICATION && code === 500) {
                    this._reconnectDelayTime = RECONNECT_DELAY_TIME_AFTER_ERROR;
                    reconnect();
                }
                setImmediate(() => {
                    this.emit(WSClient.ERROR, err);
                });
            }

            // Emit ConnectionChanged on new Connection Info or readyState.
            if (connectionChanged) {
                const connectionInfo = this._connectionInfo
                setImmediate(() => {
                    this.emit(WSClient.CONNECTIONCHANGED, connectionInfo);
                });
            }

            // Emit the whole message.
            setImmediate(() => {
                this.emit(WSClient.MESSAGE, err, message);
            });

            // Emit for those who listens to a specific reqid.
            if (message.reqid) {
                setImmediate(() => {
                    this.emit(message.reqid, err, message.data, code);
                });
            }
            // Emit for those who listens to a specific type.
            if (message.type) {
                setImmediate(() => {
                    this.emit(message.type, err, message.data, code);
                });
            }

            // Integrated actions.
            if (message.type === WSClient.AUTHENTICATION) {
                if (success) {
                    this.subscribe();
                }
            }

            // Only authenticate when server restores connection and creates a new session.
            if (message.reqid && message.type === WSClient.CONNECTION) {
                if (this.options && (this.options.auth || (this.options.usr && this.options.pwd) || typeof (this.options.authorization) === 'string')) {
                    this._log("Authenticate because server restores connection and creates a new session.");
                    this.authenticate(options);
                }
            }
        };
    }

    /**
     * Disconnect from the WebSocket server.
     *
     * @returns {void}
     */
    disconnect() {
        this._log(`Disconnecting from ${this.url}`);
        this.close(1000, "Bye Bye!");
    }

    get connectionInfo() {
        return this._connectionInfo;
    }

    /**
     * Execute function.
     *
     * @param {[Identity]} context Array with object like {
     *   "p": "/System/Core/Test/Item1"
     * }
     * @param {String} libraryName Library Script name.
     * @param {String} [functionName] Library function name.
     * @param {Object} [functionArg] Library function arguments packed in a dictionary.
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username",
     *   "pwd": "password",
     *   "ign": false, // ignore response
     *   "roe": false, // return only error
     *   "tim": 1000, // timeout
     * }
     * @returns {void}
     */
    execFunction(context, libraryName, functionName, functionArg, cb, options) {
        let functionArgType = typeof (functionArg);
        if (Array.isArray(functionArg)) functionArgType = 'array';
        if (functionArgType !== 'object' && functionArgType !== 'undefined') return invokeCallback(cb, new Error(`Argument 'functionArg' needs to be an object got '${functionArgType}'`))
        const msg = new ExecFunctionRPC(context, libraryName, functionName, functionArg, options);
        // Use callback of send when response message are ignored.
        const ignoreResp = options && options.ign === true;
        if (!ignoreResp) {
            this._subscribeReqIDCallback(msg.reqid, cb);
        }

        this.send(msg, (err) => {
            if (err || ignoreResp) return invokeCallback(cb, err);
        });
    }

    /**
     * Mass config objects.
     *
     * @param {[Object]} items Array with entries like described on wiki.inmation.com.
     *   see: https://inmation.com/wiki/index.php?title=Sysdoc/Lua_Scripting#mass__function_
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username",
     *   "pwd": "password",
     *   "ign": false, // ignore response
     *   "roe": false, // return only error
     *   "batch_flags" // See: https://inmation.com/wiki/index.php?title=Flag_groups_enum/en#MassBatchFlags
     * }
     * @returns {void}
     */
    mass(items, cb, options) {
        if (!Array.isArray(items)) {
            return invokeCallback(cb, new Error('Items is not an array.'))
        }
        const msg = new MassRPC(items, options);
        // Use callback of send when response message are ignored.
        const ignoreResp = options && options.ign === true;
        if (!ignoreResp) {
            this._subscribeReqIDCallback(msg.reqid, cb);
        }

        this.send(msg, (err) => {
            if (err || ignoreResp) return invokeCallback(cb, err);
        });
    }

    /**
     * Send a data message.
     *
     * @param {Object} data The object which needs to be send.
     * @param {Function} cb Callback which is executed when data is written out
     * @returns {void}
     * @public
     */
    send(data, cb) {
        if (this._ws && this._connectionInfo.state === WSConnectionInfo.CONNECTED) {
            const jsonData = JSON.stringify(data);
            this._log(`Sending: ${jsonData}`);
            return this._ws.send(jsonData, cb);
        }
        const stateString = this._connectionInfo.stateString
        const errMsg = `Unable to send data, connection state should be '${WSConnectionInfo.CONNECTEDSTRING}' but is '${stateString}'.`;
        return invokeCallback(cb, new Error(errMsg))
    }

    /**
     * Subscribe.
     *
     * @param {[Item]} items Array with object like {"p": "/System/Core/Test/Item1"}.
     * @param {String} type Type of subscription like CHILDRENCOUNTCHANGED, CONFIGURATIONVERSIONCHANGED, DATACHANGED, USERSTATECHANGED.
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username",
     *   "pwd": "password",
     *   "tim": 1000, // timeout
     * }
     * @returns {void}
     */
    subscribe(items, type, cb, options) {
        if (Array.isArray(items) && type) {
            this._subscriptionItems[type] = items;
            const msg = new SubscribeRPC(this._subscriptionItems[type], type, options);
            this._subscribeReqIDCallback(msg.reqid, cb);
            this.send(msg, (err) => {
                if (err) return invokeCallback(cb, err);
            });
        }
        else {
            const types = [WSClient.CHILDRENCOUNTCHANGED, WSClient.CONFIGURATIONVERSIONCHANGED, WSClient.DATACHANGED, WSClient.USERSTATECHANGED];
            for (const type of types) {
                const items = this._subscriptionItems[type];
                if (items && items.length > 0) {
                    const msg = new SubscribeRPC(items, type);
                    this.send(msg);
                }
            }
        }
    }

    /**
     * Read item values.
     *
     * @param {[Item]} items Array with object like {
     *   "p": "/System/Core/Test/Item1"
     * }
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username",
     *   "pwd": "password",
     *   "tim": 1000, // timeout
     * }
     * @returns {void}
     */
    read(items, cb, options) {
        if (!Array.isArray(items)) {
            return invokeCallback(cb, new Error('Items is not an array.'))
        }
        const msg = new ReadRPC(items, options);

        this._subscribeReqIDCallback(msg.reqid, cb);

        this.send(msg, (err) => {
            if (err) return invokeCallback(cb, err);
        });
    }

    /**
     * Read historical item values.
     *
     * @param {[HistoricalDataItem]} historicalDataItems Array with object like {
     *   "p": "/System/Core/Test/Item1"
     *   "aggregate": "AGG_TYPE_RAW"
     * }
     * @param {String} startTime Start time in UTC format.
     * @param {String} endTime End time in UTC format.
     * @param {Number} [numberOfIntervals] Number of intervals.
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username",
     *   "pwd": "password",
     *   "tim": 1000, // timeout
     *   "percentage_good": 100,
     *   "percentage_bad": 100,
     *   "treat_uncertain_as_bad": false,
     *   "sloped_extrapolation": false,
     *   "partial_interval_treatment": "UASTANDARD"
     * }
     * @returns {void}
     */
    readHistoricalData(historicalDataItems, startTime, endTime, numberOfIntervals, cb, options) {
        if (!Array.isArray(historicalDataItems)) {
            return invokeCallback(cb, new Error('Items is not an array.'))
        }
        const msg = new ReadHistoricalDataRPC(historicalDataItems, startTime, endTime, numberOfIntervals, options);

        this._subscribeReqIDCallback(msg.reqid, cb);

        this.send(msg, (err) => {
            if (err) return invokeCallback(cb, err);
        });
    }

    /**
     * Read historical item value at time.
     *
     * @param {[Object]} items Array with object like {
     *   "p": "/System/Core/Test/Item1"
     * }
     * @param {String} timestamp Time in UTC format.
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username",
     *   "pwd": "password",
     *   "tim": 1000, // timeout
     *   "sloped_extrapolation": false
     * }
     * @returns {void}
     */
    readHistoricalDataAtTime(items, timestamp, cb, options) {
        if (!Array.isArray(items)) {
            return invokeCallback(cb, new Error('Items is not an array.'))
        }
        const msg = new ReadHistoricalDataAtTimeRPC(items, timestamp, options);

        this._subscribeReqIDCallback(msg.reqid, cb);

        this.send(msg, (err) => {
            if (err) return invokeCallback(cb, err);
        });
    }

    /**
     * Read raw historical item values by query. Commonly used after readRawHistoricalData
     * which can return a query strategy.
     *
     * @param {Object} query Object or array with object like {
     *  "start_time": 1451610000000,
     *  "paths": [
     *      "System/Core/TestSliConvenienceLayer/Item01"
     *  ],
     *  "end_time": 1451610010000,
     *  "filter": {
     *      "V": {
     *          "$lt": 20
     *      }
     *  }
     * }
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username",
     *   "pwd": "password"
     * }
     * @returns {void}
     */
    readRawHistoricalDataByQuery(query, cb, options) {
        const msg = ReadRawHistoricalDataRPC.createByQuery(query, options);

        this._subscribeReqIDCallback(msg.reqid, cb);

        this.send(msg, (err) => {
            if (err) return invokeCallback(cb, err);
        });
    }

    /**
     * Run script.
     *
     * @param {[Identity]} context Array with object like {
     *   "p": "/System/Core/Test/Item1"
     * }
     * @param {string} script Script body.
     * @param {Function} [cb] Callback.
     * @param {options} [options] Can consist of {
     *   "usr": "username",
     *   "pwd": "password",
     *   "ign": false, // ignore response
     *   "roe": false, // return only error
     *   "tim": 1000, // timeout
     * }
     * @returns {void}
     */
    runScript(context, script, cb, options) {
        const msg = new RunScriptRPC(context, script, options);
        // Use callback of send when response message are ignored.
        const ignoreResp = options && options.ign === true;
        if (!ignoreResp) {
            this._subscribeReqIDCallback(msg.reqid, cb);
        }

        this.send(msg, (err) => {
            if (err || ignoreResp) return invokeCallback(cb, err);
        });
    }

    /**
     * Write item values.
     *
     * @param {[ItemValue]} items Array with object like {
     *   "p": "/System/Core/Test/Item1",
     *   "v": 10.5,
     *   "q":  0, // Quality (optional)
     *   "t": "2017-06-19T12:41:19.56Z" // timestamp (optional)
     * }
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username",
     *   "pwd": "password",
     *   "ign": false, // ignore response
     *   "roe": false, // return only error
     *   "tim": 1000, // timeout
     *   "fetch": "OPC_READ_CACHE_BEFORE_WRITE" // (write_fetch),
     *   "delay": 0, // (write_delay) AKA pack delay
     *   "audit": true, // (write_audit) SuppressAuditWrite
     *   "group": false // (write_group)
     *   "timeo": 100 // (write_timeo)
     * }
     * @returns {void}
     */
    write(items, cb, options) {
        if (!Array.isArray(items)) {
            return invokeCallback(cb, new Error('Items is not an array.'))
        }
        const msg = new WriteRPC(items, options);
        // Use callback of send when response message are ignored.
        const ignoreResp = options && options.ign === true;
        if (!ignoreResp) {
            this._subscribeReqIDCallback(msg.reqid, cb);
        }

        this.send(msg, (err) => {
            if (err || ignoreResp) return invokeCallback(cb, err);
        });
    }
}

WSClient.AUTHENTICATION = 'authentication';
WSClient.CHILDRENCOUNTCHANGED = 'childrencountchanged';
WSClient.CONNECTIONCHANGED = 'connectionchanged';
WSClient.CONFIGURATIONVERSIONCHANGED = 'configurationversionchanged'
WSClient.CONNECTION = 'connection';
WSClient.DATACHANGED = 'datachanged';
WSClient.ERROR = 'error';
WSClient.MESSAGE = 'message';
WSClient.READ = 'read';
WSClient.USERSTATECHANGED = 'userstatechanged';
WSClient.WRITE = 'write';

module.exports = {
    WSClient: WSClient
}