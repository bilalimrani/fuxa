'use strict';

const { WSClient } = require('./wsclient');
const { RawHistoricalDataQuery } = require('./model');

class Client {

    /**
     * Set up the API Client.
     * @param {Object} [options] Can consist of {
     *   "debug": "<bool>", // Write debug log to console
     *
     */
    constructor(options) {
        this._wsClient = new WSClient(options);
    }

    /**
     * Connect to the WebSocket server.
     *
     * @param {String} url URL of the WebSocket.
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "<string>", // Username (deprecated)
     *   "pwd": "<string>", // Password (deprecated)
     *   "auth": {
     *       "username": "<string>".
     *       "password": "<string>",
     *       "authority": "inmation | ad | machine",
     *       "grant_type": "password",
     *       "include_claims": string array // "email", "family_name", "given_name", "middle_name", "phone_number",
     *       "authorization": "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
     *       "disconnect_on_access_denied": true // Default true, set to false to keep connection.
     *   }
     *   "tim": 5000, // handshakeTimeout (obsolete, use wsOptions)
     *   "wsOptions?": { // see WebSocket.ClientOptions (https://github.com/websockets/ws)
     *       protocol?: string;
     *       followRedirects?: boolean;
     *       handshakeTimeout?: number;
     *       maxRedirects?: number;
     *       perMessageDeflate?: boolean | PerMessageDeflateOptions;
     *       localAddress?: string;
     *       protocolVersion?: number;
     *       headers?: { [key: string]: string };
     *       origin?: string;
     *       agent?: http.Agent;
     *       host?: string;
     *       family?: number;
     *       checkServerIdentity?(servername: string, cert: CertMeta): boolean;
     *       rejectUnauthorized?: boolean;
     *       maxPayload?: number;
     *   }
     * @returns {void}
     */
    connectWS(url, cb, options) {
        this._wsClient.connect(url, cb, options);
    }

    /**
     * Disconnect from the WebSocket server.
     *
     * @returns {void}
     */
    disconnectWS() {
        this._wsClient.disconnect();
    }

    /**
     * Authentication request to the WebSocket server.
     *
     * @param {Object} [auth] Can consist of {
     *     "username": "<string>".
     *     "password": "<string>",
     *     "authority": "inmation | ad | machine",
     *     "grant_type": "password",
     *     "include_claims": string array, //"email", "family_name", "given_name", "middle_name", "phone_number",
     *     "authorization": "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
     *     "disconnect_on_access_denied": true // Default true, set to false to keep connection.
     * }
     * @param {Function} [cb] Callback.
     * @returns {void}
     */
    authenticate(auth, cb) {
        const options = {
            auth: auth
        }
        this._wsClient.authenticate(options, cb);
    }

    /**
     * Execute function.
     *
     * @param {[Identity]} context Array with object like {
     *   "p": "/System/Core/Test/Item1"
     * }
     * @param {String} libraryName Library Script name.
     * @param {String} [functionName] Library function name.
     * @param {Object} [functionArg] Library function arguments packed in a dictionary.
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username", (deprecated)
     *   "pwd": "password", (deprecated)
     *   "ign": false, // ignore response
     *   "roe": false, // return only error
     *   "tim": 1000, // timeout
     *   "scc": "" // scope comment
     * }
     * @returns {void}
     */
    execFunction(context, libraryName, functionName, functionArg, cb, options) {
        this._wsClient.execFunction(context, libraryName, functionName, functionArg, cb, options);
    }

    /**
     * Mass config objects.
     *
     * @param {[Object]} items Array with entries like described on wiki.inmation.com.
     *   see: https://inmation.com/wiki/index.php?title=Sysdoc/Lua_Scripting#mass__function_
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username", (deprecated)
     *   "pwd": "password", (deprecated)
     *   "ign": false, // ignore response
     *   "roe": false, // return only error
     *   "batch_flags": ['simulate'], // array with See inmation.model.flags.MassBatchFlags
     *   "fields": ['all'], // Array to hide certain keys like 'p', 'c', 'n' or 'all'
     *   "scc": "" // scope comment
     * }
     * @returns {void}
     */
    mass(items, cb, options) {
        this._wsClient.mass(items, cb, options);
    }

    on(eventName, closure) {
        if (typeof (closure) !== 'function') return;

        this._wsClient.on(eventName, closure);
    }

    onChildrenCountChanged(closure) {
        this.on(WSClient.CHILDRENCOUNTCHANGED, closure);
    }

    onConfigurationVersionChanged(closure) {
        this.on(WSClient.CONFIGURATIONVERSIONCHANGED, closure);
    }

    /**
     * onWSConnectionChanged.
     *
     * @param {Function} [closure] (model.WSConnectionInfo).
     * @returns {void}
     */
    onWSConnectionChanged(closure) {
        this.on(WSClient.CONNECTIONCHANGED, closure);
    }

    onDataChanged(closure) {
        this.on(WSClient.DATACHANGED, closure);
    }

    onError(closure) {
        this.on(WSClient.ERROR, closure);
    }

    onMessage(closure) {
        this.on(WSClient.MESSAGE, closure);
    }

    onConnection(closure) {
        this.on(WSClient.CONNECTION, closure);
    }

    onUserStateChanged(closure) {
        this.on(WSClient.USERSTATECHANGED, closure);
    }

    /**
     * Run script.
     *
     * @param {[]} context Array with object like {
     * "p": "/System/Core/Test/Item1"
     * }
     * @param {String} script Script body.
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     * "usr": "username", (deprecated)
     * "pwd": "password", (deprecated)
     * "ign": false, // ignore response
     * "roe": false, // return only error
     * "tim": 1000, // timeout
     * "scc": "" // scope comment
     * }
     * @returns {void}
     */
    runScript(context, script, cb, options) {
        this._wsClient.runScript(context, script, cb, options);
    }

    /**
     * Read item values.
     *
     * @param {[Item]} items Array with object like {
     *   "p": "/System/Core/Test/Item1"
     * }
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username", (deprecated)
     *   "pwd": "password", (deprecated)
     *   "tim": 1000, // timeout
     * }
     * @returns {void}
     */
    read(items, cb, options) {
        this._wsClient.read(items, cb, options);
    }

    /**
     * Read historical item values.
     *
     * @param {[Object]} historicalDataItems Array with object like {
     *   "p": "/System/Core/Test/Item1",
     *   "aggregate": "AGG_TYPE_RAW"
     * }
     * @param {String} startTime Start time in UTC format.
     * @param {String} endTime End time in UTC format.
     * @param {Number} [numberOfIntervals] Number of intervals.
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username", (deprecated)
     *   "pwd": "password", (deprecated)
     *   "tim": 1000, // timeout
     *   "percentage_good": 100,
     *   "percentage_bad": 100,
     *   "treat_uncertain_as_bad": false,
     *   "sloped_extrapolation": false,
     *   "partial_interval_treatment": "UASTANDARD"
     * }
     * @returns {void}
     */
    readHistoricalData(historicalDataItems, startTime, endTime, numberOfIntervals, cb, options) {
        this._wsClient.readHistoricalData(historicalDataItems, startTime, endTime, numberOfIntervals, cb, options);
    }

    /**
     * Read historical item value at time.
     *
     * @param {[Object]} items Array with object like {
     *   "p": "/System/Core/Test/Item1"
     * }
     * @param {String} timestamp Time in UTC format.
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username", (deprecated)
     *   "pwd": "password", (deprecated)
     *   "tim": 1000, // timeout
     *   "sloped_extrapolation": false
     * }
     * @returns {void}
     */
    readHistoricalDataAtTime(items, timestamp, cb, options) {
        this._wsClient.readHistoricalDataAtTime(items, timestamp, cb, options);
    }

    /**
     * Read raw historical item values.
     *
     * @param {Object} items Object or array with object like {
     *   "p": "/System/Core/Test/Item1"
     * }
     * @param {String} startTime Start time in UTC format.
     * @param {String} endTime End time in UTC format.
     * @param {Object} [filter] Mongo Filter Expression.
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username",
     *   "pwd": "password"
     * }
     * @returns {void}
     */
    readRawHistoricalData(items, startTime, endTime, filter, cb, options) {
        const query = new RawHistoricalDataQuery(items, startTime, endTime, filter, options);
        this._wsClient.readRawHistoricalDataByQuery(query, cb, options);
    }

    /**
     * Read raw historical item values by query. Commonly used after readRawHistoricalData
     * which can return a query strategy.
     *
     * @param {Object} query Object or array with object like {
     *  "start_time": 1451610000000,
     *  "paths": [
     *      "System/Core/TestSliConvenienceLayer/Item01"
     *  ],
     *  "end_time": 1451610010000,
     *  "filter": {
     *      "V": {
     *          "$lt": 20
     *      }
     *  },
     *  "post_execution": [
     *      {
     *          "lib": "my_library",
     *          "func": "process"
     *      },
     *      {
     *          "lib": "my_library",
     *          "func": "calc",
     *          farg: {
     *              factor: 2
     *          }
     *      }
     *  ]
     * }
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username", (deprecated)
     *   "pwd": "password" (deprecated)
     * }
     * @returns {void}
     */
    readRawHistoricalDataByQuery(query, cb, options) {
        this._wsClient.readRawHistoricalDataByQuery(query, cb, options);
    }

    /**
     * Subscribe to ChildrenCount changed.
     *
     * @param {[Item]} items Array with { "p": "/itemspath"}
     * @param {Function} [cb] Callback.
     * @returns {void}
     */
    subscribeToChildrenCountChanges(items, cb) {
        this._wsClient.subscribe(items, WSClient.CHILDRENCOUNTCHANGED, cb);
    }

    /**
     * Subscribe to ConfigurationVersion changed.
     *
     * @param {[Item]} items Array with { "p": "/itemspath"}
     * @param {Function} [cb] Callback.
     * @returns {void}
     */
    subscribeToConfigurationVersionChanges(items, cb) {
        this._wsClient.subscribe(items, WSClient.CONFIGURATIONVERSIONCHANGED, cb);
    }

    /**
     * Subscribe to Data changes.
     *
     * @param {[Item]} items Array with { "p": "/itemspath"}
     * @param {Function} [cb] Callback.
     * @returns {void}
     */
    subscribeToDataChanges(items, cb) {
        this._wsClient.subscribe(items, WSClient.DATACHANGED, cb);
    }

    /**
     * Subscribe to UserState changes.
     *
     * @param {[Item]} items Array with { "p": "/itemspath"}
     * @param {Function} [cb] Callback.
     * @returns {void}
     */
    subscribeToUserStateChanges(items, cb) {
        this._wsClient.subscribe(items, WSClient.USERSTATECHANGED, cb);
    }

    /**
     * Write item values.
     *
     * @param {[ItemValue]} items Array with object like {
     *   "p": "/System/Core/Test/Item1",
     *   "v": 10.5,
     *   "q":  0, // Quality (optional)
     *   "t": "2017-06-19T12:41:19.56Z" // timestamp (optional)
     * }
     * @param {Function} [cb] Callback.
     * @param {Object} [options] Can consist of {
     *   "usr": "username", (deprecated)
     *   "pwd": "password", (deprecated)
     *   "ign": false, // ignore response
     *   "roe": false, // return only error
     *   "tim": 1000, // timeout
     *   "fetch": "OPC_READ_CACHE_BEFORE_WRITE" // (write_fetch),
     *   "delay": 0, // (write_delay) AKA pack delay
     *   "audit": true, // (write_audit) SuppressAuditWrite
     *   "group": false, // (write_group)
     *   "timeo": 100, // (write_timeo)
     *   "scc": "" // scope comment
     * }
     * @returns {void}
     */
    write(items, cb, options) {
        this._wsClient.write(items, cb, options);
    }

    /**
    * wsConnectionInfo.
    *
    * @returns {Object} WSConnectionInfo with sessionid and autheticated flag.
    */
    get wsConnectionInfo() {
        return this._wsClient.connectionInfo;
    }
}

module.exports = {
    Client: Client
}