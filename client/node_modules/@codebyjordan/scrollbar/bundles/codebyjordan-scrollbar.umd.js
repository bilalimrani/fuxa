(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/Observable'), require('rxjs/add/observable/fromEvent'), require('rxjs/Subject'), require('rxjs/add/observable/from'), require('rxjs/add/observable/merge'), require('rxjs/add/operator/mergeMap'), require('rxjs/add/operator/takeUntil'), require('rxjs/add/operator/map'), require('rxjs/add/operator/filter'), require('@angular/router'), require('@angular/common')) :
	typeof define === 'function' && define.amd ? define('@codebyjordan/scrollbar', ['exports', '@angular/core', 'rxjs/Observable', 'rxjs/add/observable/fromEvent', 'rxjs/Subject', 'rxjs/add/observable/from', 'rxjs/add/observable/merge', 'rxjs/add/operator/mergeMap', 'rxjs/add/operator/takeUntil', 'rxjs/add/operator/map', 'rxjs/add/operator/filter', '@angular/router', '@angular/common'], factory) :
	(factory((global.codebyjordan = global.codebyjordan || {}, global.codebyjordan.scrollbar = {}),global.ng.core,global.Rx,global.Rx.Observable,global.Rx,global.Rx.Observable,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.ng.router,global.ng.common));
}(this, (function (exports,core,Observable,fromEvent,Subject,from,merge,mergeMap,takeUntil,map,filter,router,common) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */









function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var DEFAULT_SCROLLBAR = {
    isBrowser: false,
    isRoot: false,
    position: 'right',
    alwaysVisible: false,
    visibleTimeout: 3000,
    wrapperWidth: '100%',
    gridOffset: 0,
    barOffset: '.5rem',
    styles: {
        grid: {
            'position': 'absolute',
            'top': 0,
            'bottom': 0,
            'display': 'block',
            'cursor': 'pointer',
            'z-index': 99999,
            'background': 'transparent',
            'width': '1rem',
            'border-radius': 0,
            'margin': 0,
            'transition': 'opacity 250ms ease-in-out'
        },
        bar: {
            'position': 'absolute',
            'top': 0,
            'display': 'block',
            'cursor': 'pointer',
            'transition': 'opacity 250ms ease-in-out',
            'z-index': 100000,
            'background': '#495057',
            'width': '.7rem',
            'border-radius': '10px',
            'margin': 0
        }
    },
    classes: {
        wrapper: ['cbj-scroll-wrapper'],
        grid: ['cbj-scroll-grid'],
        bar: ['cbj-scroll-bar']
    }
};
var ScrollbarConfig = (function () {
    function ScrollbarConfig(opt) {
        this.mergeOptions(opt, true);
    }
    ScrollbarConfig.prototype.mergeOptions = function (opt, setOpt, mergeWith) {
        if (setOpt === void 0) { setOpt = false; }
        var defaults = DEFAULT_SCROLLBAR;
        if (mergeWith) {
            defaults = mergeWith;
        }
        var styles = {};
        var classes = {};
        if (opt.styles) {
            var keys = Object.keys(opt.styles);
            try {
                for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                    var key = keys_1_1.value;
                    styles[key] = Object.assign({}, defaults.styles[key], opt.styles[key]);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            styles = Object.assign({}, defaults.styles, styles);
        }
        else {
            styles = Object.assign({}, defaults.styles);
        }
        if (opt.classes) {
            var keys = Object.keys(opt.classes);
            try {
                for (var keys_2 = __values(keys), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {
                    var key = keys_2_1.value;
                    classes[key] = __spread(defaults.classes[key], opt.classes[key]);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (keys_2_1 && !keys_2_1.done && (_b = keys_2.return)) _b.call(keys_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            classes = Object.assign({}, defaults.classes, classes);
        }
        else {
            classes = Object.assign({}, defaults.classes);
        }
        var out = Object.assign({}, defaults, opt, { styles: styles }, { classes: classes });
        if (setOpt) {
            this.options = out;
        }
        return out;
        var e_1, _a, e_2, _b;
    };
    Object.defineProperty(ScrollbarConfig.prototype, "isBrowser", {
        get: function () {
            return this.options.isBrowser;
        },
        set: function (is) {
            this.options.isBrowser = is;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarConfig.prototype, "isRoot", {
        get: function () {
            return this.options.isRoot;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarConfig.prototype, "position", {
        get: function () {
            return this.options.position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarConfig.prototype, "alwaysVisible", {
        get: function () {
            return this.options.alwaysVisible;
        },
        set: function (vis) {
            this.options.alwaysVisible = vis;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarConfig.prototype, "visibleTimeout", {
        get: function () {
            return this.options.visibleTimeout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarConfig.prototype, "wrapperWidth", {
        get: function () {
            return this.options.wrapperWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarConfig.prototype, "gridOffset", {
        get: function () {
            return this.options.gridOffset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarConfig.prototype, "barOffset", {
        get: function () {
            return this.options.barOffset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarConfig.prototype, "toggleClasses", {
        get: function () {
            return this.options.toggleClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarConfig.prototype, "wStyles", {
        get: function () {
            return this.options.styles.wrapper;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarConfig.prototype, "gStyles", {
        get: function () {
            return this.options.styles.grid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarConfig.prototype, "bStyles", {
        get: function () {
            return this.options.styles.bar;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarConfig.prototype, "wClass", {
        get: function () {
            return this.options.classes.wrapper;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarConfig.prototype, "gClass", {
        get: function () {
            return this.options.classes.grid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarConfig.prototype, "bClass", {
        get: function () {
            return this.options.classes.bar;
        },
        enumerable: true,
        configurable: true
    });
    return ScrollbarConfig;
}());
var WINDOW = new core.InjectionToken('Window');
function _window() { return window; }
var WindowService = (function () {
    function WindowService(w) {
        this.w = w;
        this.resizeObs = Observable.Observable.fromEvent(w, 'resize');
    }
    Object.defineProperty(WindowService.prototype, "window", {
        get: function () {
            return this.w;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowService.prototype, "width", {
        get: function () {
            return this.w.innerWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowService.prototype, "isMobile", {
        get: function () {
            return this.width < 992;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowService.prototype, "height", {
        get: function () {
            return this._height ? this._height : this.w.innerHeight;
        },
        set: function (height) {
            this._height = height;
        },
        enumerable: true,
        configurable: true
    });
    return WindowService;
}());
WindowService.decorators = [
    { type: core.Injectable },
];
WindowService.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: core.Inject, args: [WINDOW,] },] },
]; };
var ScrollbarService = (function () {
    function ScrollbarService(ws) {
        this.ws = ws;
        this.scrollSubj = new Subject.Subject();
        this.ngUnsubscribe = new Subject.Subject();
        this.scrollObs = Observable.Observable.from(this.scrollSubj);
        this.childScrolling = false;
    }
    Object.defineProperty(ScrollbarService.prototype, "scrollHeight", {
        get: function () {
            return this._scrollHeight ? this._scrollHeight : this.ws.window.document.documentElement.scrollHeight;
        },
        set: function (height) {
            this._scrollHeight = height;
        },
        enumerable: true,
        configurable: true
    });
    ScrollbarService.prototype.ngOnDestroy = function () {
        this.ngUnsubscribe.next();
        this.ngUnsubscribe.complete();
    };
    ScrollbarService.prototype.initWheel = function (el) {
        var dommousescroll = Observable.Observable.fromEvent(el, 'DOMMouseScroll');
        var mousewheel = Observable.Observable.fromEvent(el, 'mousewheel');
        var wheel = Observable.Observable.fromEvent(el, 'wheel');
        return Observable.Observable.merge.apply(Observable.Observable, __spread([dommousescroll, mousewheel, wheel])).map(function (e) {
            e.preventDefault();
            var data = { x: 0, y: 0, type: 'wheel' };
            if (e.wheelDelta) {
                data.y = -1 / 40 * e.wheelDelta;
                data.x = e.wheelDeltaX ? -1 / 40 * e.wheelDeltaX : 0;
            }
            else {
                data.y = e.deltaY || e.detail;
            }
            return data;
        });
    };
    ScrollbarService.prototype.initDrag = function (el, bar) {
        var _this = this;
        var observs;
        var mousemove = Observable.Observable.fromEvent(this.ws.window, 'mousemove');
        var mousedown = Observable.Observable.fromEvent(bar, 'mousedown');
        var mouseup = Observable.Observable.fromEvent(this.ws.window, 'mouseup');
        var mousedrag = mousedown.mergeMap(function (e) {
            var pageY = e.pageY;
            var top = parseFloat(_this.ws.window.getComputedStyle(bar).top);
            return mousemove.map(function (emove) {
                emove.preventDefault();
                return top + emove.pageY - pageY;
            }).takeUntil(mouseup);
        });
        observs = {
            start: mousedrag,
            end: mouseup,
            move: mousemove
        };
        if (this.ws.isMobile) {
            var touchmove_1 = Observable.Observable.fromEvent(this.ws.window, 'touchmove');
            var touchstart = Observable.Observable.fromEvent(el, 'touchstart');
            var touchend_1 = Observable.Observable.fromEvent(this.ws.window, 'touchend');
            var touchdrag = touchstart.mergeMap(function (e) {
                var pageY = e.targetTouches[0].pageY;
                var top = -parseFloat(_this.ws.window.getComputedStyle(bar).top);
                return touchmove_1.map(function (tmove) {
                    return -(top + tmove.targetTouches[0].pageY - pageY);
                }).takeUntil(touchend_1);
            });
            observs = {
                start: Observable.Observable.merge.apply(Observable.Observable, __spread([mousedrag, touchdrag])),
                end: Observable.Observable.merge.apply(Observable.Observable, __spread([mouseup, touchend_1])),
                move: Observable.Observable.merge.apply(Observable.Observable, __spread([mousemove, touchstart]))
            };
        }
        return observs;
    };
    ScrollbarService.prototype.getElOffsetTop = function (el) {
        var viewportTop = el.nativeElement.getBoundingClientRect().top;
        var clientTop = el.nativeElement.clientTop;
        return viewportTop + this.scrollPos - clientTop;
    };
    ScrollbarService.prototype.getElOffsetBottom = function (el) {
        var viewportTop = el.nativeElement.getBoundingClientRect().top;
        var clientBottom = el.nativeElement.clientTop + el.nativeElement.clientHeight;
        return viewportTop + this.scrollPos - clientBottom;
    };
    return ScrollbarService;
}());
ScrollbarService.decorators = [
    { type: core.Injectable },
];
ScrollbarService.ctorParameters = function () { return [
    { type: WindowService, },
]; };
var easing = {
    linear: function (t) { return t; },
    inQuad: function (t) { return t * t; },
    outQuad: function (t) { return t * (2 - t); },
    inOutQuad: function (t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; },
    inCubic: function (t) { return t * t * t; },
    outCubic: function (t) { return (--t) * t * t + 1; },
    inOutCubic: function (t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; },
    inQuart: function (t) { return t * t * t * t; },
    outQuart: function (t) { return 1 - (--t) * t * t * t; },
    inOutQuart: function (t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t; },
    inQuint: function (t) { return t * t * t * t * t; },
    outQuint: function (t) { return 1 + (--t) * t * t * t * t; },
    inOutQuint: function (t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t; }
};
var CbjScrollbarDirective = (function () {
    function CbjScrollbarDirective(el, renderer, scroll, ws, router$$1) {
        var _this = this;
        this.el = el;
        this.renderer = renderer;
        this.scroll = scroll;
        this.ws = ws;
        this.router = router$$1;
        this.unsubscribe = new Subject.Subject();
        this.isBrowser = false;
        this.timers = [];
        this.setBarHeight = function () {
            var natEl = _this.el.nativeElement;
            _this.scrollHeight = Math.round(natEl.scrollHeight);
            var barHeight = (natEl.offsetHeight / natEl.scrollHeight) * natEl.offsetHeight;
            _this.renderer.setStyle(_this.bar, 'height', barHeight + "px");
            if ((!_this.barNeeded(natEl.offsetHeight, barHeight) || !_this.config.alwaysVisible || _this.hidden) &&
                _this.isBrowser) {
                _this.showHideBarGrid();
            }
            if (_this.config.isRoot) {
                _this.ws.height = natEl.clientHeight;
                _this.scroll.scrollHeight = _this.scrollHeight;
            }
        };
        this.toggleClasses = function (nxt) {
            if (nxt.remove) {
                _this.renderer.removeClass(_this[nxt.el], nxt.classes);
            }
            else {
                _this.renderer.addClass(_this[nxt.el], nxt.classes);
            }
        };
        this.showHideBarGrid = function () {
            var natEl = _this.el.nativeElement;
            var barHeight = (natEl.offsetHeight / natEl.scrollHeight) * natEl.offsetHeight;
            _this.notNeeded = !_this.barNeeded(natEl.offsetHeight, barHeight);
            if (!_this.hidden) {
                if (_this.notNeeded || !_this.config.alwaysVisible) {
                    _this.renderer.setStyle(_this.grid, 'opacity', 0);
                    _this.renderer.setStyle(_this.bar, 'opacity', 0);
                    _this.hidden = true;
                }
            }
            else {
                if (!_this.notNeeded) {
                    _this.renderer.setStyle(_this.grid, 'opacity', 1);
                    _this.renderer.setStyle(_this.bar, 'opacity', 1);
                    _this.hidden = false;
                    if (!_this.config.alwaysVisible) {
                        clearTimeout(_this.timeout);
                        _this.timeout = setTimeout(_this.showHideBarGrid, _this.config.visibleTimeout);
                    }
                }
            }
        };
        this.resetTime = function () {
            clearTimeout(_this.timeout);
            if (_this.hidden && !_this.notNeeded) {
                _this.renderer.setStyle(_this.grid, 'opacity', 1);
                _this.renderer.setStyle(_this.bar, 'opacity', 1);
                _this.hidden = false;
            }
            _this.timeout = setTimeout(_this.showHideBarGrid, _this.config.visibleTimeout);
        };
        this.dragStart = function (top) {
            if (!_this.config.isRoot) {
                _this.scroll.childScrolling = true;
            }
            if (!_this.config.isRoot || (_this.config.isRoot && _this.scroll.childScrolling === false)) {
                _this.renderer.setStyle(_this.bar, 'top', top + "px");
                _this.scrollContent();
            }
        };
        this.scrollContent = function () {
            var natEl = _this.el.nativeElement;
            var maxTop = natEl.offsetHeight - _this.bar.offsetHeight;
            var percentScroll;
            var delta = parseInt(_this.ws.window.getComputedStyle(_this.bar).top, 10);
            delta = Math.min(Math.max(delta, 0), maxTop);
            delta = Math.floor(delta);
            _this.renderer.setStyle(_this.bar, 'top', delta + 'px');
            percentScroll = parseInt(_this.ws.window.getComputedStyle(_this.bar).top, 10) / (natEl.offsetHeight - _this.bar.offsetHeight);
            delta = percentScroll * (natEl.scrollHeight - natEl.offsetHeight);
            natEl.scrollTop = delta;
            if (_this.config.isRoot) {
                _this.scroll.scrollPos = delta;
                _this.scroll.scrollSubj.next(delta);
            }
        };
        this.dragEnd = function () {
            var natEl = _this.el.nativeElement;
            var paddingTop = parseInt(natEl.style.paddingTop, 10);
            var paddingBottom = parseInt(natEl.style.paddingBottom, 10);
            if (paddingTop > 0 || paddingBottom > 0) {
                _this.scrollTo(0, 300, 'inOutCubic');
            }
            if (!_this.config.isRoot) {
                _this.scroll.childScrolling = false;
            }
        };
        this.scrollWheel = function (event) {
            if (!_this.config.isRoot) {
                _this.scroll.childScrolling = true;
            }
            var natEl = _this.el.nativeElement;
            var start = Date.now();
            var maxTop = natEl.offsetHeight - _this.bar.offsetHeight;
            var percentScroll;
            var delta;
            var scroll = function () {
                var currentTime = Date.now();
                var time = Math.min(1, ((currentTime - start) / 200));
                var easedTime = easing["inOutQuad"](time);
                delta = parseInt(_this.ws.window.getComputedStyle(_this.bar).top, 10) + event.y * easedTime;
                delta = Math.min(Math.max(delta, 0), maxTop);
                delta = (event.y > 0) ? Math.ceil(delta) : Math.floor(delta);
                _this.renderer.setStyle(_this.bar, 'top', delta + 'px');
                percentScroll = parseInt(_this.ws.window.getComputedStyle(_this.bar).top, 10) / (natEl.offsetHeight - _this.bar.offsetHeight);
                delta = percentScroll * (natEl.scrollHeight - natEl.offsetHeight);
                natEl.scrollTop = delta;
                if (_this.config.isRoot) {
                    _this.scroll.scrollPos = delta;
                    _this.scroll.scrollSubj.next(delta);
                }
                if (time < 1) {
                    _this.ws.window.requestAnimationFrame(scroll);
                }
                if (!_this.config.isRoot) {
                    _this.scroll.childScrolling = false;
                }
            };
            if (!_this.config.isRoot || (_this.config.isRoot && _this.scroll.childScrolling === false)) {
                _this.ws.window.requestAnimationFrame(scroll);
            }
        };
    }
    CbjScrollbarDirective.prototype.ngOnInit = function () {
        this.isBrowser = this.config.isBrowser;
        if (!this.isBrowser) {
            this.config.alwaysVisible = true;
        }
        this.createScrollbar();
    };
    CbjScrollbarDirective.prototype.ngAfterViewInit = function () {
        if (this.isBrowser) {
            var t = setTimeout(this.setBarHeight, 250);
            this.timers.push(t);
        }
        else {
            this.setBarHeight();
        }
    };
    CbjScrollbarDirective.prototype.ngAfterViewChecked = function () {
        var dif = this.scrollHeight !== Math.round(this.el.nativeElement.scrollHeight);
        if (dif) {
            this.setBarHeight();
        }
    };
    CbjScrollbarDirective.prototype.ngOnDestroy = function () {
        this.timers.forEach(function (timer) { return clearTimeout(timer); });
        clearTimeout(this.timeout);
        this.unsubscribe.next();
        this.unsubscribe.complete();
    };
    CbjScrollbarDirective.prototype.createScrollbar = function () {
        this.setParentsStyles();
        this.setElementStyle();
        this.renderWrapper();
        this.renderGrid();
        this.renderBar();
        if (this.isBrowser) {
            this.subscribe();
        }
    };
    CbjScrollbarDirective.prototype.setParentsStyles = function () {
        var natEl = this.el.nativeElement;
        var parent = this.renderer.parentNode(natEl);
        this.renderer.setStyle(parent, 'position', 'relative');
        var body = this.ws.window.document.getElementsByTagName('BODY')[0];
        this.renderer.setStyle(body, 'overflow', 'hidden');
    };
    CbjScrollbarDirective.prototype.setElementStyle = function () {
        var natEl = this.el.nativeElement;
        this.renderer.setStyle(natEl, 'overflow', 'hidden');
    };
    CbjScrollbarDirective.prototype.renderWrapper = function () {
        var _this = this;
        var natEl = this.el.nativeElement;
        this.wrapper = this.renderer.createElement('div');
        try {
            for (var _a = __values(this.config.wClass), _b = _a.next(); !_b.done; _b = _a.next()) {
                var cls = _b.value;
                this.renderer.addClass(this.wrapper, cls);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_3) throw e_3.error; }
        }
        var setDStyles = function () {
            _this.renderer.setStyle(_this.wrapper, 'margin', _this.ws.window.getComputedStyle(natEl).margin);
            _this.renderer.setStyle(_this.wrapper, 'height', _this.ws.window.getComputedStyle(natEl).height);
        };
        if (this.isBrowser) {
            var t = setTimeout(setDStyles, 250);
            this.timers.push(t);
        }
        else {
            setDStyles();
        }
        if (this.config.wrapperWidth) {
            this.renderer.setStyle(this.wrapper, 'width', this.config.wrapperWidth);
        }
        for (var prop in this.config.wStyles) {
            if (this.config.wStyles.hasOwnProperty(prop)) {
                this.renderer.setStyle(this.wrapper, prop, this.config.wStyles[prop]);
            }
        }
        this.renderer.insertBefore(this.renderer.parentNode(natEl), this.wrapper, natEl);
        this.renderer.appendChild(this.wrapper, natEl);
        var e_3, _c;
    };
    CbjScrollbarDirective.prototype.renderGrid = function () {
        this.grid = this.renderer.createElement('div');
        try {
            for (var _a = __values(this.config.gClass), _b = _a.next(); !_b.done; _b = _a.next()) {
                var cls = _b.value;
                this.renderer.addClass(this.grid, cls);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_4) throw e_4.error; }
        }
        this.renderer.setStyle(this.grid, this.config.position, this.config.gridOffset);
        for (var prop in this.config.gStyles) {
            if (this.config.gStyles.hasOwnProperty(prop)) {
                this.renderer.setStyle(this.grid, prop, this.config.gStyles[prop]);
            }
        }
        if (!this.config.alwaysVisible && this.isBrowser) {
            this.renderer.setStyle(this.grid, 'opacity', 0);
        }
        this.renderer.appendChild(this.wrapper, this.grid);
        var e_4, _c;
    };
    CbjScrollbarDirective.prototype.renderBar = function () {
        this.bar = this.renderer.createElement('div');
        try {
            for (var _a = __values(this.config.bClass), _b = _a.next(); !_b.done; _b = _a.next()) {
                var cls = _b.value;
                this.renderer.addClass(this.bar, cls);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_5) throw e_5.error; }
        }
        var translate = this.config.position === 'right' ? 'translate3d(50%, 0, 0)' : 'translate3d(-50%, 0, 0)';
        this.renderer.setStyle(this.bar, 'transform', translate);
        this.renderer.setStyle(this.bar, this.config.position, this.config.barOffset);
        for (var prop in this.config.bStyles) {
            if (this.config.bStyles.hasOwnProperty(prop)) {
                this.renderer.setStyle(this.bar, prop, this.config.bStyles[prop]);
            }
        }
        if (!this.config.alwaysVisible && this.isBrowser) {
            this.renderer.setStyle(this.bar, 'opacity', 0);
            this.hidden = true;
        }
        else {
            this.hidden = false;
        }
        this.renderer.appendChild(this.wrapper, this.bar);
        var e_5, _c;
    };
    CbjScrollbarDirective.prototype.subscribe = function () {
        var _this = this;
        var natEl = this.el.nativeElement;
        var drag = this.scroll.initDrag(natEl, this.bar);
        this.scroll.initWheel(natEl)
            .takeUntil(this.unsubscribe)
            .subscribe(this.scrollWheel);
        this.ws.resizeObs.takeUntil(this.unsubscribe).subscribe(this.setBarHeight);
        drag.start.takeUntil(this.unsubscribe).subscribe(this.dragStart);
        drag.end.takeUntil(this.unsubscribe).subscribe(this.dragEnd);
        if (!this.config.alwaysVisible) {
            drag.move.takeUntil(this.unsubscribe).subscribe(this.resetTime);
        }
        if (this.config.isRoot && this.router && this.isBrowser) {
            this.router.events
                .filter(function (event) { return event instanceof router.NavigationStart; })
                .subscribe(function (e) {
                _this.scrollTo(0, 100, 'linear');
            });
        }
        if (this.config.toggleClasses) {
            Observable.Observable.from(this.config.toggleClasses)
                .takeUntil(this.unsubscribe)
                .subscribe(this.toggleClasses);
        }
    };
    CbjScrollbarDirective.prototype.barNeeded = function (elHeight, barHeight) {
        return Math.round(elHeight) - Math.round(barHeight) > 2;
    };
    CbjScrollbarDirective.prototype.scrollTo = function (y, duration, easingFunc) {
        var _this = this;
        var natEl = this.el.nativeElement;
        var start = Date.now();
        var from$$1 = natEl.scrollTop;
        var maxElScrollTop = natEl.scrollHeight - natEl.clientHeight;
        var barHeight = Math.max((natEl.offsetHeight / natEl.scrollHeight) * natEl.offsetHeight, 30);
        var paddingTop = parseInt(natEl.style.paddingTop, 10) || 0;
        var paddingBottom = parseInt(natEl.style.paddingBottom, 10) || 0;
        var scroll = function () {
            var currentTime = Date.now();
            var time = Math.min(1, ((currentTime - start) / duration));
            var easedTime = easing[easingFunc](time);
            if (paddingTop > 0 || paddingBottom > 0) {
                var fromY = null;
                if (paddingTop > 0) {
                    fromY = -paddingTop;
                    fromY = -((easedTime * (y - fromY)) + fromY);
                    _this.renderer.setStyle(natEl, 'paddingTop', fromY + "px");
                }
                if (paddingBottom > 0) {
                    fromY = paddingBottom;
                    fromY = ((easedTime * (y - fromY)) + fromY);
                    _this.renderer.setStyle(natEl, 'paddingBottom', fromY + "px");
                }
            }
            else {
                natEl.scrollTop = (easedTime * (y - from$$1)) + from$$1;
            }
            var percentScroll = natEl.scrollTop / maxElScrollTop;
            if (paddingBottom === 0) {
                var delta = Math.round(Math.round(natEl.clientHeight * percentScroll) - barHeight);
                if (delta > 0) {
                    _this.renderer.setStyle(_this.bar, 'top', delta + "px");
                }
                else {
                    _this.renderer.setStyle(_this.bar, 'top', "0");
                }
            }
            if (time < 1) {
                _this.ws.window.requestAnimationFrame(scroll);
            }
        };
        this.ws.window.requestAnimationFrame(scroll);
    };
    return CbjScrollbarDirective;
}());
CbjScrollbarDirective.decorators = [
    { type: core.Directive, args: [{
                selector: '[cbjScrollbar]'
            },] },
];
CbjScrollbarDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
    { type: ScrollbarService, },
    { type: WindowService, },
    { type: router.Router, decorators: [{ type: core.Optional },] },
]; };
CbjScrollbarDirective.propDecorators = {
    "config": [{ type: core.Input, args: ['cbjScrollbar',] },],
};
var CbjScrollbarModule = (function () {
    function CbjScrollbarModule() {
    }
    CbjScrollbarModule.forRoot = function () {
        return {
            ngModule: CbjScrollbarModule,
            providers: [
                { provide: WINDOW, useFactory: _window },
                WindowService,
                ScrollbarService
            ]
        };
    };
    return CbjScrollbarModule;
}());
CbjScrollbarModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule
                ],
                declarations: [
                    CbjScrollbarDirective
                ],
                exports: [
                    CbjScrollbarDirective
                ]
            },] },
];

exports.DEFAULT_SCROLLBAR = DEFAULT_SCROLLBAR;
exports.ScrollbarConfig = ScrollbarConfig;
exports.WINDOW = WINDOW;
exports._window = _window;
exports.WindowService = WindowService;
exports.ScrollbarService = ScrollbarService;
exports.CbjScrollbarDirective = CbjScrollbarDirective;
exports.CbjScrollbarModule = CbjScrollbarModule;
exports.ɵa = CbjScrollbarDirective;
exports.ɵb = ScrollbarService;
exports.ɵd = WINDOW;
exports.ɵe = _window;
exports.ɵc = WindowService;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=codebyjordan-scrollbar.umd.js.map
