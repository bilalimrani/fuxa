{"remainingRequest":"/Users/bilal/Documents/GitHub/FUXA/client/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/bilal/Documents/GitHub/FUXA/client/node_modules/angular2-draggable/fesm5/angular2-draggable.js","dependencies":[{"path":"/Users/bilal/Documents/GitHub/FUXA/client/node_modules/angular2-draggable/fesm5/angular2-draggable.js","mtime":499162500000},{"path":"/Users/bilal/Documents/GitHub/FUXA/client/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/bilal/Documents/GitHub/FUXA/client/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START tslib,rxjs,_angular_core PURE_IMPORTS_END */\nimport { __values, __assign } from 'tslib';\nimport { fromEvent } from 'rxjs';\nimport { Directive, ElementRef, Renderer2, Input, Output, HostListener, EventEmitter, NgModule } from '@angular/core';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar Position = /** @class */ /*@__PURE__*/ (function () {\n    function Position(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    /**\n     * @param {?} e\n     * @param {?=} el\n     * @return {?}\n     */\n    Position.fromEvent = /**\n     * @param {?} e\n     * @param {?=} el\n     * @return {?}\n     */\n        function (e, el) {\n            if (el === void 0) {\n                el = null;\n            }\n            /**\n             * Fix issue: Resize doesn't work on Windows10 IE11 (and on some windows 7 IE11)\n             * https://github.com/xieziyu/angular2-draggable/issues/164\n             * e instanceof MouseEvent check returns false on IE11\n             */\n            if (this.isMouseEvent(e)) {\n                return new Position(e.clientX, e.clientY);\n            }\n            else {\n                if (el === null || e.changedTouches.length === 1) {\n                    return new Position(e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n                }\n                /**\n                 * Fix issue: Multiple phone draggables at the same time\n                 * https://github.com/xieziyu/angular2-draggable/issues/128\n                 */\n                for (var i = 0; i < e.changedTouches.length; i++) {\n                    if (e.changedTouches[i].target === el) {\n                        return new Position(e.changedTouches[i].clientX, e.changedTouches[i].clientY);\n                    }\n                }\n            }\n        };\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    Position.isMouseEvent = /**\n     * @param {?} e\n     * @return {?}\n     */\n        function (e) {\n            return Object.prototype.toString.apply(e).indexOf('MouseEvent') === 8;\n        };\n    /**\n     * @param {?} obj\n     * @return {?}\n     */\n    Position.isIPosition = /**\n     * @param {?} obj\n     * @return {?}\n     */\n        function (obj) {\n            return !!obj && ('x' in obj) && ('y' in obj);\n        };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    Position.getCurrent = /**\n     * @param {?} el\n     * @return {?}\n     */\n        function (el) {\n            /** @type {?} */\n            var pos = new Position(0, 0);\n            if (window) {\n                /** @type {?} */\n                var computed = window.getComputedStyle(el);\n                if (computed) {\n                    /** @type {?} */\n                    var x = parseInt(computed.getPropertyValue('left'), 10);\n                    /** @type {?} */\n                    var y = parseInt(computed.getPropertyValue('top'), 10);\n                    pos.x = isNaN(x) ? 0 : x;\n                    pos.y = isNaN(y) ? 0 : y;\n                }\n                return pos;\n            }\n            else {\n                console.error('Not Supported!');\n                return null;\n            }\n        };\n    /**\n     * @param {?} p\n     * @return {?}\n     */\n    Position.copy = /**\n     * @param {?} p\n     * @return {?}\n     */\n        function (p) {\n            return new Position(0, 0).set(p);\n        };\n    Object.defineProperty(Position.prototype, \"value\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return { x: this.x, y: this.y };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @template THIS\n     * @this {THIS}\n     * @param {?} p\n     * @return {THIS}\n     */\n    Position.prototype.add = /**\n     * @template THIS\n     * @this {THIS}\n     * @param {?} p\n     * @return {THIS}\n     */\n        function (p) {\n            ( /** @type {?} */(this)).x += p.x;\n            ( /** @type {?} */(this)).y += p.y;\n            return ( /** @type {?} */(this));\n        };\n    /**\n     * @template THIS\n     * @this {THIS}\n     * @param {?} p\n     * @return {THIS}\n     */\n    Position.prototype.subtract = /**\n     * @template THIS\n     * @this {THIS}\n     * @param {?} p\n     * @return {THIS}\n     */\n        function (p) {\n            ( /** @type {?} */(this)).x -= p.x;\n            ( /** @type {?} */(this)).y -= p.y;\n            return ( /** @type {?} */(this));\n        };\n    /**\n     * @param {?} n\n     * @return {?}\n     */\n    Position.prototype.multiply = /**\n     * @param {?} n\n     * @return {?}\n     */\n        function (n) {\n            this.x *= n;\n            this.y *= n;\n        };\n    /**\n     * @param {?} n\n     * @return {?}\n     */\n    Position.prototype.divide = /**\n     * @param {?} n\n     * @return {?}\n     */\n        function (n) {\n            this.x /= n;\n            this.y /= n;\n        };\n    /**\n     * @template THIS\n     * @this {THIS}\n     * @return {THIS}\n     */\n    Position.prototype.reset = /**\n     * @template THIS\n     * @this {THIS}\n     * @return {THIS}\n     */\n        function () {\n            ( /** @type {?} */(this)).x = 0;\n            ( /** @type {?} */(this)).y = 0;\n            return ( /** @type {?} */(this));\n        };\n    /**\n     * @template THIS\n     * @this {THIS}\n     * @param {?} p\n     * @return {THIS}\n     */\n    Position.prototype.set = /**\n     * @template THIS\n     * @this {THIS}\n     * @param {?} p\n     * @return {THIS}\n     */\n        function (p) {\n            ( /** @type {?} */(this)).x = p.x;\n            ( /** @type {?} */(this)).y = p.y;\n            return ( /** @type {?} */(this));\n        };\n    return Position;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar HelperBlock = /** @class */ /*@__PURE__*/ (function () {\n    function HelperBlock(parent, renderer) {\n        this.parent = parent;\n        this.renderer = renderer;\n        this._added = false;\n        // generate helper div\n        /** @type {?} */\n        var helper = renderer.createElement('div');\n        renderer.setStyle(helper, 'position', 'absolute');\n        renderer.setStyle(helper, 'width', '100%');\n        renderer.setStyle(helper, 'height', '100%');\n        renderer.setStyle(helper, 'background-color', 'transparent');\n        renderer.setStyle(helper, 'top', '0');\n        renderer.setStyle(helper, 'left', '0');\n        // done\n        this._helper = helper;\n    }\n    /**\n     * @return {?}\n     */\n    HelperBlock.prototype.add = /**\n     * @return {?}\n     */\n        function () {\n            // append div to parent\n            if (this.parent && !this._added) {\n                this.parent.appendChild(this._helper);\n                this._added = true;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    HelperBlock.prototype.remove = /**\n     * @return {?}\n     */\n        function () {\n            if (this.parent && this._added) {\n                this.parent.removeChild(this._helper);\n                this._added = false;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    HelperBlock.prototype.dispose = /**\n     * @return {?}\n     */\n        function () {\n            this._helper = null;\n            this._added = false;\n        };\n    Object.defineProperty(HelperBlock.prototype, \"el\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._helper;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return HelperBlock;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar AngularDraggableDirective = /** @class */ /*@__PURE__*/ (function () {\n    function AngularDraggableDirective(el, renderer) {\n        this.el = el;\n        this.renderer = renderer;\n        this.allowDrag = true;\n        this.moving = false;\n        this.orignal = null;\n        this.oldTrans = new Position(0, 0);\n        this.tempTrans = new Position(0, 0);\n        this.currTrans = new Position(0, 0);\n        this.oldZIndex = '';\n        this._zIndex = '';\n        this.needTransform = false;\n        this.draggingSub = null;\n        /**\n         * Bugfix: iFrames, and context unrelated elements block all events, and are unusable\n         * https://github.com/xieziyu/angular2-draggable/issues/84\n         */\n        this._helperBlock = null;\n        this.started = new EventEmitter();\n        this.stopped = new EventEmitter();\n        this.edge = new EventEmitter();\n        /**\n         * List of allowed out of bounds edges *\n         */\n        this.outOfBounds = {\n            top: false,\n            right: false,\n            bottom: false,\n            left: false\n        };\n        /**\n         * Round the position to nearest grid\n         */\n        this.gridSize = 1;\n        /**\n         * Whether to limit the element stay in the bounds\n         */\n        this.inBounds = false;\n        /**\n         * Whether the element should use it's previous drag position on a new drag event.\n         */\n        this.trackPosition = true;\n        /**\n         * Input css scale transform of element so translations are correct\n         */\n        this.scale = 1;\n        /**\n         * Whether to prevent default event\n         */\n        this.preventDefaultEvent = false;\n        /**\n         * Set initial position by offsets\n         */\n        this.position = { x: 0, y: 0 };\n        /**\n         * Lock axis: 'x' or 'y'\n         */\n        this.lockAxis = null;\n        /**\n         * Emit position offsets when moving\n         */\n        this.movingOffset = new EventEmitter();\n        /**\n         * Emit position offsets when put back\n         */\n        this.endOffset = new EventEmitter();\n        this._helperBlock = new HelperBlock(el.nativeElement, renderer);\n    }\n    Object.defineProperty(AngularDraggableDirective.prototype, \"zIndex\", {\n        /** Set z-index when not dragging */\n        set: /**\n         * Set z-index when not dragging\n         * @param {?} setting\n         * @return {?}\n         */ function (setting) {\n            this.renderer.setStyle(this.el.nativeElement, 'z-index', setting);\n            this._zIndex = setting;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AngularDraggableDirective.prototype, \"ngDraggable\", {\n        set: /**\n         * @param {?} setting\n         * @return {?}\n         */ function (setting) {\n            if (setting !== undefined && setting !== null && setting !== '') {\n                this.allowDrag = !!setting;\n                /** @type {?} */\n                var element = this.getDragEl();\n                if (this.allowDrag) {\n                    this.renderer.addClass(element, 'ng-draggable');\n                }\n                else {\n                    this.putBack();\n                    this.renderer.removeClass(element, 'ng-draggable');\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            if (this.allowDrag) {\n                /** @type {?} */\n                var element = this.getDragEl();\n                this.renderer.addClass(element, 'ng-draggable');\n            }\n            this.resetPosition();\n        };\n    /**\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this.bounds = null;\n            this.handle = null;\n            this.orignal = null;\n            this.oldTrans = null;\n            this.tempTrans = null;\n            this.currTrans = null;\n            this._helperBlock.dispose();\n            this._helperBlock = null;\n            if (this.draggingSub) {\n                this.draggingSub.unsubscribe();\n            }\n        };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            if (changes['position'] && !changes['position'].isFirstChange()) {\n                /** @type {?} */\n                var p = changes['position'].currentValue;\n                if (!this.moving) {\n                    if (Position.isIPosition(p)) {\n                        this.oldTrans.set(p);\n                    }\n                    else {\n                        this.oldTrans.reset();\n                    }\n                    this.transform();\n                }\n                else {\n                    this.needTransform = true;\n                }\n            }\n        };\n    /**\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            if (this.inBounds) {\n                this.boundsCheck();\n                this.oldTrans.add(this.tempTrans);\n                this.tempTrans.reset();\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.getDragEl = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            return this.handle ? this.handle : this.el.nativeElement;\n        };\n    /**\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.resetPosition = /**\n     * @return {?}\n     */\n        function () {\n            if (Position.isIPosition(this.position)) {\n                this.oldTrans.set(this.position);\n            }\n            else {\n                this.oldTrans.reset();\n            }\n            this.tempTrans.reset();\n            this.transform();\n        };\n    /**\n     * @private\n     * @param {?} p\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.moveTo = /**\n     * @private\n     * @param {?} p\n     * @return {?}\n     */\n        function (p) {\n            if (this.orignal) {\n                p.subtract(this.orignal);\n                this.tempTrans.set(p);\n                this.tempTrans.divide(this.scale);\n                this.transform();\n                if (this.bounds) {\n                    this.edge.emit(this.boundsCheck());\n                }\n                this.movingOffset.emit(this.currTrans.value);\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.transform = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var translateX = this.tempTrans.x + this.oldTrans.x;\n            /** @type {?} */\n            var translateY = this.tempTrans.y + this.oldTrans.y;\n            if (this.lockAxis === 'x') {\n                translateX = this.oldTrans.x;\n                this.tempTrans.x = 0;\n            }\n            else if (this.lockAxis === 'y') {\n                translateY = this.oldTrans.y;\n                this.tempTrans.y = 0;\n            }\n            // Snap to grid: by grid size\n            if (this.gridSize > 1) {\n                translateX = Math.round(translateX / this.gridSize) * this.gridSize;\n                translateY = Math.round(translateY / this.gridSize) * this.gridSize;\n            }\n            /** @type {?} */\n            var value = \"translate(\" + Math.round(translateX) + \"px, \" + Math.round(translateY) + \"px)\";\n            this.renderer.setStyle(this.el.nativeElement, 'transform', value);\n            this.renderer.setStyle(this.el.nativeElement, '-webkit-transform', value);\n            this.renderer.setStyle(this.el.nativeElement, '-ms-transform', value);\n            this.renderer.setStyle(this.el.nativeElement, '-moz-transform', value);\n            this.renderer.setStyle(this.el.nativeElement, '-o-transform', value);\n            // save current position\n            this.currTrans.x = translateX;\n            this.currTrans.y = translateY;\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.pickUp = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            // get old z-index:\n            this.oldZIndex = this.el.nativeElement.style.zIndex ? this.el.nativeElement.style.zIndex : '';\n            if (window) {\n                this.oldZIndex = window.getComputedStyle(this.el.nativeElement, null).getPropertyValue('z-index');\n            }\n            if (this.zIndexMoving) {\n                this.renderer.setStyle(this.el.nativeElement, 'z-index', this.zIndexMoving);\n            }\n            if (!this.moving) {\n                this.started.emit(this.el.nativeElement);\n                this.moving = true;\n                /** @type {?} */\n                var element = this.getDragEl();\n                this.renderer.addClass(element, 'ng-dragging');\n                /**\n                 * Fix performance issue:\n                 * https://github.com/xieziyu/angular2-draggable/issues/112\n                 */\n                this.subscribeEvents();\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.subscribeEvents = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this.draggingSub = fromEvent(document, 'mousemove', { passive: false }).subscribe(function (event) { return _this.onMouseMove(( /** @type {?} */(event))); });\n            this.draggingSub.add(fromEvent(document, 'touchmove', { passive: false }).subscribe(function (event) { return _this.onMouseMove(( /** @type {?} */(event))); }));\n            this.draggingSub.add(fromEvent(document, 'mouseup', { passive: false }).subscribe(function () { return _this.putBack(); }));\n            // checking if browser is IE or Edge - https://github.com/xieziyu/angular2-draggable/issues/153\n            /** @type {?} */\n            var isIEOrEdge = /msie\\s|trident\\//i.test(window.navigator.userAgent);\n            if (!isIEOrEdge) {\n                this.draggingSub.add(fromEvent(document, 'mouseleave', { passive: false }).subscribe(function () { return _this.putBack(); }));\n            }\n            this.draggingSub.add(fromEvent(document, 'touchend', { passive: false }).subscribe(function () { return _this.putBack(); }));\n            this.draggingSub.add(fromEvent(document, 'touchcancel', { passive: false }).subscribe(function () { return _this.putBack(); }));\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.unsubscribeEvents = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            this.draggingSub.unsubscribe();\n            this.draggingSub = null;\n        };\n    /**\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.boundsCheck = /**\n     * @return {?}\n     */\n        function () {\n            if (this.bounds) {\n                /** @type {?} */\n                var boundary = this.bounds.getBoundingClientRect();\n                /** @type {?} */\n                var elem = this.el.nativeElement.getBoundingClientRect();\n                /** @type {?} */\n                var result = {\n                    'top': this.outOfBounds.top ? true : boundary.top < elem.top,\n                    'right': this.outOfBounds.right ? true : boundary.right > elem.right,\n                    'bottom': this.outOfBounds.bottom ? true : boundary.bottom > elem.bottom,\n                    'left': this.outOfBounds.left ? true : boundary.left < elem.left\n                };\n                if (this.inBounds) {\n                    if (!result.top) {\n                        this.tempTrans.y -= (elem.top - boundary.top) / this.scale;\n                    }\n                    if (!result.bottom) {\n                        this.tempTrans.y -= (elem.bottom - boundary.bottom) / this.scale;\n                    }\n                    if (!result.right) {\n                        this.tempTrans.x -= (elem.right - boundary.right) / this.scale;\n                    }\n                    if (!result.left) {\n                        this.tempTrans.x -= (elem.left - boundary.left) / this.scale;\n                    }\n                    this.transform();\n                }\n                return result;\n            }\n        };\n    /** Get current offset */\n    /**\n     * Get current offset\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.getCurrentOffset = /**\n     * Get current offset\n     * @return {?}\n     */\n        function () {\n            return this.currTrans.value;\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.putBack = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            if (this._zIndex) {\n                this.renderer.setStyle(this.el.nativeElement, 'z-index', this._zIndex);\n            }\n            else if (this.zIndexMoving) {\n                if (this.oldZIndex) {\n                    this.renderer.setStyle(this.el.nativeElement, 'z-index', this.oldZIndex);\n                }\n                else {\n                    this.el.nativeElement.style.removeProperty('z-index');\n                }\n            }\n            if (this.moving) {\n                this.stopped.emit(this.el.nativeElement);\n                // Remove the helper div:\n                this._helperBlock.remove();\n                if (this.needTransform) {\n                    if (Position.isIPosition(this.position)) {\n                        this.oldTrans.set(this.position);\n                    }\n                    else {\n                        this.oldTrans.reset();\n                    }\n                    this.transform();\n                    this.needTransform = false;\n                }\n                if (this.bounds) {\n                    this.edge.emit(this.boundsCheck());\n                }\n                this.moving = false;\n                this.endOffset.emit(this.currTrans.value);\n                if (this.trackPosition) {\n                    this.oldTrans.add(this.tempTrans);\n                }\n                this.tempTrans.reset();\n                if (!this.trackPosition) {\n                    this.transform();\n                }\n                /** @type {?} */\n                var element = this.getDragEl();\n                this.renderer.removeClass(element, 'ng-dragging');\n                /**\n                 * Fix performance issue:\n                 * https://github.com/xieziyu/angular2-draggable/issues/112\n                 */\n                this.unsubscribeEvents();\n            }\n        };\n    /**\n     * @param {?} target\n     * @param {?} element\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.checkHandleTarget = /**\n     * @param {?} target\n     * @param {?} element\n     * @return {?}\n     */\n        function (target, element) {\n            // Checks if the target is the element clicked, then checks each child element of element as well\n            // Ignores button clicks\n            // Ignore elements of type button\n            if (element.tagName === 'BUTTON') {\n                return false;\n            }\n            // If the target was found, return true (handle was found)\n            if (element === target) {\n                return true;\n            }\n            // Recursively iterate this elements children\n            for (var child in element.children) {\n                if (element.children.hasOwnProperty(child)) {\n                    if (this.checkHandleTarget(target, element.children[child])) {\n                        return true;\n                    }\n                }\n            }\n            // Handle was not found in this lineage\n            // Note: return false is ignore unless it is the parent element\n            return false;\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.onMouseDown = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            // 1. skip right click;\n            if (event instanceof MouseEvent && event.button === 2) {\n                return;\n            }\n            // 2. if handle is set, the element can only be moved by handle\n            /** @type {?} */\n            var target = event.target || event.srcElement;\n            if (this.handle !== undefined && !this.checkHandleTarget(target, this.handle)) {\n                return;\n            }\n            // 3. if allow drag is set to false, ignore the mousedown\n            if (this.allowDrag === false) {\n                return;\n            }\n            if (this.preventDefaultEvent) {\n                event.stopPropagation();\n                event.preventDefault();\n            }\n            this.orignal = Position.fromEvent(event, this.getDragEl());\n            this.pickUp();\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    AngularDraggableDirective.prototype.onMouseMove = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this.moving && this.allowDrag) {\n                if (this.preventDefaultEvent) {\n                    event.stopPropagation();\n                    event.preventDefault();\n                }\n                // Add a transparent helper div:\n                this._helperBlock.add();\n                this.moveTo(Position.fromEvent(event, this.getDragEl()));\n            }\n        };\n    return AngularDraggableDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ResizeHandle = /** @class */ /*@__PURE__*/ (function () {\n    function ResizeHandle(parent, renderer, type, css, onMouseDown) {\n        var _this = this;\n        this.parent = parent;\n        this.renderer = renderer;\n        this.type = type;\n        this.css = css;\n        this.onMouseDown = onMouseDown;\n        // generate handle div\n        /** @type {?} */\n        var handle = renderer.createElement('div');\n        renderer.addClass(handle, 'ng-resizable-handle');\n        renderer.addClass(handle, css);\n        // add default diagonal for se handle\n        if (type === 'se') {\n            renderer.addClass(handle, 'ng-resizable-diagonal');\n        }\n        // append div to parent\n        if (this.parent) {\n            parent.appendChild(handle);\n        }\n        // create and register event listener\n        this._onResize = function (event) { onMouseDown(event, _this); };\n        handle.addEventListener('mousedown', this._onResize, { passive: false });\n        handle.addEventListener('touchstart', this._onResize, { passive: false });\n        // done\n        this._handle = handle;\n    }\n    /**\n     * @return {?}\n     */\n    ResizeHandle.prototype.dispose = /**\n     * @return {?}\n     */\n        function () {\n            this._handle.removeEventListener('mousedown', this._onResize);\n            this._handle.removeEventListener('touchstart', this._onResize);\n            if (this.parent) {\n                this.parent.removeChild(this._handle);\n            }\n            this._handle = null;\n            this._onResize = null;\n        };\n    Object.defineProperty(ResizeHandle.prototype, \"el\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._handle;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return ResizeHandle;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar Size = /** @class */ /*@__PURE__*/ (function () {\n    function Size(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    Size.getCurrent = /**\n     * @param {?} el\n     * @return {?}\n     */\n        function (el) {\n            /** @type {?} */\n            var size = new Size(0, 0);\n            if (window) {\n                /** @type {?} */\n                var computed = window.getComputedStyle(el);\n                if (computed) {\n                    size.width = parseInt(computed.getPropertyValue('width'), 10);\n                    size.height = parseInt(computed.getPropertyValue('height'), 10);\n                }\n                return size;\n            }\n            else {\n                console.error('Not Supported!');\n                return null;\n            }\n        };\n    /**\n     * @param {?} s\n     * @return {?}\n     */\n    Size.copy = /**\n     * @param {?} s\n     * @return {?}\n     */\n        function (s) {\n            return new Size(0, 0).set(s);\n        };\n    /**\n     * @template THIS\n     * @this {THIS}\n     * @param {?} s\n     * @return {THIS}\n     */\n    Size.prototype.set = /**\n     * @template THIS\n     * @this {THIS}\n     * @param {?} s\n     * @return {THIS}\n     */\n        function (s) {\n            ( /** @type {?} */(this)).width = s.width;\n            ( /** @type {?} */(this)).height = s.height;\n            return ( /** @type {?} */(this));\n        };\n    return Size;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar AngularResizableDirective = /** @class */ /*@__PURE__*/ (function () {\n    function AngularResizableDirective(el, renderer) {\n        this.el = el;\n        this.renderer = renderer;\n        this._resizable = true;\n        this._handles = {};\n        this._handleType = [];\n        this._handleResizing = null;\n        this._direction = null;\n        this._directionChanged = null;\n        this._aspectRatio = 0;\n        this._containment = null;\n        this._origMousePos = null;\n        /**\n         * Original Size and Position\n         */\n        this._origSize = null;\n        this._origPos = null;\n        /**\n         * Current Size and Position\n         */\n        this._currSize = null;\n        this._currPos = null;\n        /**\n         * Initial Size and Position\n         */\n        this._initSize = null;\n        this._initPos = null;\n        /**\n         * Snap to gird\n         */\n        this._gridSize = null;\n        this._bounding = null;\n        /**\n         * Bugfix: iFrames, and context unrelated elements block all events, and are unusable\n         * https://github.com/xieziyu/angular2-draggable/issues/84\n         */\n        this._helperBlock = null;\n        this.draggingSub = null;\n        this._adjusted = false;\n        /**\n         * Which handles can be used for resizing.\n         * \\@example\n         * [rzHandles] = \"'n,e,s,w,se,ne,sw,nw'\"\n         * equals to: [rzHandles] = \"'all'\"\n         *\n         *\n         */\n        this.rzHandles = 'e,s,se';\n        /**\n         * Whether the element should be constrained to a specific aspect ratio.\n         *  Multiple types supported:\n         *  boolean: When set to true, the element will maintain its original aspect ratio.\n         *  number: Force the element to maintain a specific aspect ratio during resizing.\n         */\n        this.rzAspectRatio = false;\n        /**\n         * Constrains resizing to within the bounds of the specified element or region.\n         *  Multiple types supported:\n         *  Selector: The resizable element will be contained to the bounding box of the first element found by the selector.\n         *            If no element is found, no containment will be set.\n         *  Element: The resizable element will be contained to the bounding box of this element.\n         *  String: Possible values: \"parent\".\n         */\n        this.rzContainment = null;\n        /**\n         * Snaps the resizing element to a grid, every x and y pixels.\n         * A number for both width and height or an array values like [ x, y ]\n         */\n        this.rzGrid = null;\n        /**\n         * The minimum width the resizable should be allowed to resize to.\n         */\n        this.rzMinWidth = null;\n        /**\n         * The minimum height the resizable should be allowed to resize to.\n         */\n        this.rzMinHeight = null;\n        /**\n         * The maximum width the resizable should be allowed to resize to.\n         */\n        this.rzMaxWidth = null;\n        /**\n         * The maximum height the resizable should be allowed to resize to.\n         */\n        this.rzMaxHeight = null;\n        /**\n         * Whether to prevent default event\n         */\n        this.preventDefaultEvent = true;\n        /**\n         * emitted when start resizing\n         */\n        this.rzStart = new EventEmitter();\n        /**\n         * emitted when start resizing\n         */\n        this.rzResizing = new EventEmitter();\n        /**\n         * emitted when stop resizing\n         */\n        this.rzStop = new EventEmitter();\n        this._helperBlock = new HelperBlock(el.nativeElement, renderer);\n    }\n    Object.defineProperty(AngularResizableDirective.prototype, \"ngResizable\", {\n        /** Disables the resizable if set to false. */\n        set: /**\n         * Disables the resizable if set to false.\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            if (v !== undefined && v !== null && v !== '') {\n                this._resizable = !!v;\n                this.updateResizable();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            if (changes['rzHandles'] && !changes['rzHandles'].isFirstChange()) {\n                this.updateResizable();\n            }\n            if (changes['rzAspectRatio'] && !changes['rzAspectRatio'].isFirstChange()) {\n                this.updateAspectRatio();\n            }\n            if (changes['rzContainment'] && !changes['rzContainment'].isFirstChange()) {\n                this.updateContainment();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this.updateResizable();\n        };\n    /**\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this.removeHandles();\n            this._containment = null;\n            this._helperBlock.dispose();\n            this._helperBlock = null;\n        };\n    /**\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var elm = this.el.nativeElement;\n            this._initSize = Size.getCurrent(elm);\n            this._initPos = Position.getCurrent(elm);\n            this._currSize = Size.copy(this._initSize);\n            this._currPos = Position.copy(this._initPos);\n            this.updateAspectRatio();\n            this.updateContainment();\n        };\n    /** A method to reset size */\n    /**\n     * A method to reset size\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.resetSize = /**\n     * A method to reset size\n     * @return {?}\n     */\n        function () {\n            this._currSize = Size.copy(this._initSize);\n            this._currPos = Position.copy(this._initPos);\n            this.doResize();\n        };\n    /** A method to get current status */\n    /**\n     * A method to get current status\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.getStatus = /**\n     * A method to get current status\n     * @return {?}\n     */\n        function () {\n            if (!this._currPos || !this._currSize) {\n                return null;\n            }\n            return {\n                size: {\n                    width: this._currSize.width,\n                    height: this._currSize.height\n                },\n                position: {\n                    top: this._currPos.y,\n                    left: this._currPos.x\n                }\n            };\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.updateResizable = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var element = this.el.nativeElement;\n            // clear handles:\n            this.renderer.removeClass(element, 'ng-resizable');\n            this.removeHandles();\n            // create new ones:\n            if (this._resizable) {\n                this.renderer.addClass(element, 'ng-resizable');\n                this.createHandles();\n            }\n        };\n    /** Use it to update aspect */\n    /**\n     * Use it to update aspect\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.updateAspectRatio = /**\n     * Use it to update aspect\n     * @private\n     * @return {?}\n     */\n        function () {\n            if (typeof this.rzAspectRatio === 'boolean') {\n                if (this.rzAspectRatio && this._currSize.height) {\n                    this._aspectRatio = (this._currSize.width / this._currSize.height);\n                }\n                else {\n                    this._aspectRatio = 0;\n                }\n            }\n            else {\n                /** @type {?} */\n                var r = Number(this.rzAspectRatio);\n                this._aspectRatio = isNaN(r) ? 0 : r;\n            }\n        };\n    /** Use it to update containment */\n    /**\n     * Use it to update containment\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.updateContainment = /**\n     * Use it to update containment\n     * @private\n     * @return {?}\n     */\n        function () {\n            if (!this.rzContainment) {\n                this._containment = null;\n                return;\n            }\n            if (typeof this.rzContainment === 'string') {\n                if (this.rzContainment === 'parent') {\n                    this._containment = this.el.nativeElement.parentElement;\n                }\n                else {\n                    this._containment = document.querySelector(this.rzContainment);\n                }\n            }\n            else {\n                this._containment = this.rzContainment;\n            }\n        };\n    /** Use it to create handle divs */\n    /**\n     * Use it to create handle divs\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.createHandles = /**\n     * Use it to create handle divs\n     * @private\n     * @return {?}\n     */\n        function () {\n            var e_1, _a, e_2, _b;\n            if (!this.rzHandles) {\n                return;\n            }\n            /** @type {?} */\n            var tmpHandleTypes;\n            if (typeof this.rzHandles === 'string') {\n                if (this.rzHandles === 'all') {\n                    tmpHandleTypes = ['n', 'e', 's', 'w', 'ne', 'se', 'nw', 'sw'];\n                }\n                else {\n                    tmpHandleTypes = this.rzHandles.replace(/ /g, '').toLowerCase().split(',');\n                }\n                try {\n                    for (var tmpHandleTypes_1 = __values(tmpHandleTypes), tmpHandleTypes_1_1 = tmpHandleTypes_1.next(); !tmpHandleTypes_1_1.done; tmpHandleTypes_1_1 = tmpHandleTypes_1.next()) {\n                        var type = tmpHandleTypes_1_1.value;\n                        // default handle theme: ng-resizable-$type.\n                        /** @type {?} */\n                        var handle = this.createHandleByType(type, \"ng-resizable-\" + type);\n                        if (handle) {\n                            this._handleType.push(type);\n                            this._handles[type] = handle;\n                        }\n                    }\n                }\n                catch (e_1_1) {\n                    e_1 = { error: e_1_1 };\n                }\n                finally {\n                    try {\n                        if (tmpHandleTypes_1_1 && !tmpHandleTypes_1_1.done && (_a = tmpHandleTypes_1.return))\n                            _a.call(tmpHandleTypes_1);\n                    }\n                    finally {\n                        if (e_1)\n                            throw e_1.error;\n                    }\n                }\n            }\n            else {\n                tmpHandleTypes = Object.keys(this.rzHandles);\n                try {\n                    for (var tmpHandleTypes_2 = __values(tmpHandleTypes), tmpHandleTypes_2_1 = tmpHandleTypes_2.next(); !tmpHandleTypes_2_1.done; tmpHandleTypes_2_1 = tmpHandleTypes_2.next()) {\n                        var type = tmpHandleTypes_2_1.value;\n                        // custom handle theme.\n                        /** @type {?} */\n                        var handle = this.createHandleByType(type, this.rzHandles[type]);\n                        if (handle) {\n                            this._handleType.push(type);\n                            this._handles[type] = handle;\n                        }\n                    }\n                }\n                catch (e_2_1) {\n                    e_2 = { error: e_2_1 };\n                }\n                finally {\n                    try {\n                        if (tmpHandleTypes_2_1 && !tmpHandleTypes_2_1.done && (_b = tmpHandleTypes_2.return))\n                            _b.call(tmpHandleTypes_2);\n                    }\n                    finally {\n                        if (e_2)\n                            throw e_2.error;\n                    }\n                }\n            }\n        };\n    /** Use it to create a handle */\n    /**\n     * Use it to create a handle\n     * @private\n     * @param {?} type\n     * @param {?} css\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.createHandleByType = /**\n     * Use it to create a handle\n     * @private\n     * @param {?} type\n     * @param {?} css\n     * @return {?}\n     */\n        function (type, css) {\n            /** @type {?} */\n            var _el = this.el.nativeElement;\n            if (!type.match(/^(se|sw|ne|nw|n|e|s|w)$/)) {\n                console.error('Invalid handle type:', type);\n                return null;\n            }\n            return new ResizeHandle(_el, this.renderer, type, css, this.onMouseDown.bind(this));\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.removeHandles = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            var e_3, _a;\n            try {\n                for (var _b = __values(this._handleType), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var type = _c.value;\n                    this._handles[type].dispose();\n                }\n            }\n            catch (e_3_1) {\n                e_3 = { error: e_3_1 };\n            }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return))\n                        _a.call(_b);\n                }\n                finally {\n                    if (e_3)\n                        throw e_3.error;\n                }\n            }\n            this._handleType = [];\n            this._handles = {};\n        };\n    /**\n     * @param {?} event\n     * @param {?} handle\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.onMouseDown = /**\n     * @param {?} event\n     * @param {?} handle\n     * @return {?}\n     */\n        function (event, handle) {\n            // skip right click;\n            if (event instanceof MouseEvent && event.button === 2) {\n                return;\n            }\n            if (this.preventDefaultEvent) {\n                // prevent default events\n                event.stopPropagation();\n                event.preventDefault();\n            }\n            if (!this._handleResizing) {\n                this._origMousePos = Position.fromEvent(event);\n                this.startResize(handle);\n                this.subscribeEvents();\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.subscribeEvents = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this.draggingSub = fromEvent(document, 'mousemove', { passive: false }).subscribe(function (event) { return _this.onMouseMove(( /** @type {?} */(event))); });\n            this.draggingSub.add(fromEvent(document, 'touchmove', { passive: false }).subscribe(function (event) { return _this.onMouseMove(( /** @type {?} */(event))); }));\n            this.draggingSub.add(fromEvent(document, 'mouseup', { passive: false }).subscribe(function () { return _this.onMouseLeave(); }));\n            // fix for issue #164\n            /** @type {?} */\n            var isIEOrEdge = /msie\\s|trident\\//i.test(window.navigator.userAgent);\n            if (!isIEOrEdge) {\n                this.draggingSub.add(fromEvent(document, 'mouseleave', { passive: false }).subscribe(function () { return _this.onMouseLeave(); }));\n            }\n            this.draggingSub.add(fromEvent(document, 'touchend', { passive: false }).subscribe(function () { return _this.onMouseLeave(); }));\n            this.draggingSub.add(fromEvent(document, 'touchcancel', { passive: false }).subscribe(function () { return _this.onMouseLeave(); }));\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.unsubscribeEvents = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            this.draggingSub.unsubscribe();\n            this.draggingSub = null;\n        };\n    /**\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.onMouseLeave = /**\n     * @return {?}\n     */\n        function () {\n            if (this._handleResizing) {\n                this.stopResize();\n                this._origMousePos = null;\n                this.unsubscribeEvents();\n            }\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.onMouseMove = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this._handleResizing && this._resizable && this._origMousePos && this._origPos && this._origSize) {\n                this.resizeTo(Position.fromEvent(event));\n                this.onResizing();\n            }\n        };\n    /**\n     * @private\n     * @param {?} handle\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.startResize = /**\n     * @private\n     * @param {?} handle\n     * @return {?}\n     */\n        function (handle) {\n            /** @type {?} */\n            var elm = this.el.nativeElement;\n            this._origSize = Size.getCurrent(elm);\n            this._origPos = Position.getCurrent(elm); // x: left, y: top\n            this._currSize = Size.copy(this._origSize);\n            this._currPos = Position.copy(this._origPos);\n            if (this._containment) {\n                this.getBounding();\n            }\n            this.getGridSize();\n            // Add a transparent helper div:\n            this._helperBlock.add();\n            this._handleResizing = handle;\n            this.updateDirection();\n            this.rzStart.emit(this.getResizingEvent());\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.stopResize = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            // Remove the helper div:\n            this._helperBlock.remove();\n            this.rzStop.emit(this.getResizingEvent());\n            this._handleResizing = null;\n            this._direction = null;\n            this._origSize = null;\n            this._origPos = null;\n            if (this._containment) {\n                this.resetBounding();\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.onResizing = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            this.rzResizing.emit(this.getResizingEvent());\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.getResizingEvent = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            return {\n                host: this.el.nativeElement,\n                handle: this._handleResizing ? this._handleResizing.el : null,\n                size: {\n                    width: this._currSize.width,\n                    height: this._currSize.height\n                },\n                position: {\n                    top: this._currPos.y,\n                    left: this._currPos.x\n                },\n                direction: __assign({}, this._directionChanged),\n            };\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.updateDirection = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            this._direction = {\n                n: !!this._handleResizing.type.match(/n/),\n                s: !!this._handleResizing.type.match(/s/),\n                w: !!this._handleResizing.type.match(/w/),\n                e: !!this._handleResizing.type.match(/e/)\n            };\n            this._directionChanged = __assign({}, this._direction);\n            // if aspect ration should be preserved:\n            if (this.rzAspectRatio) {\n                // if north then west (unless ne)\n                if (this._directionChanged.n && !this._directionChanged.e) {\n                    this._directionChanged.w = true;\n                }\n                // if south then east (unless sw)\n                if (this._directionChanged.s && !this._directionChanged.w) {\n                    this._directionChanged.e = true;\n                }\n                // if east then south (unless ne)\n                if (this._directionChanged.e && !this._directionChanged.n) {\n                    this._directionChanged.s = true;\n                }\n                // if west then south (unless nw)\n                if (this._directionChanged.w && !this._directionChanged.n) {\n                    this._directionChanged.s = true;\n                }\n            }\n        };\n    /**\n     * @private\n     * @param {?} p\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.resizeTo = /**\n     * @private\n     * @param {?} p\n     * @return {?}\n     */\n        function (p) {\n            p.subtract(this._origMousePos);\n            /** @type {?} */\n            var tmpX = Math.round(p.x / this._gridSize.x) * this._gridSize.x;\n            /** @type {?} */\n            var tmpY = Math.round(p.y / this._gridSize.y) * this._gridSize.y;\n            if (this._direction.n) {\n                // n, ne, nw\n                this._currPos.y = this._origPos.y + tmpY;\n                this._currSize.height = this._origSize.height - tmpY;\n            }\n            else if (this._direction.s) {\n                // s, se, sw\n                this._currSize.height = this._origSize.height + tmpY;\n            }\n            if (this._direction.e) {\n                // e, ne, se\n                this._currSize.width = this._origSize.width + tmpX;\n            }\n            else if (this._direction.w) {\n                // w, nw, sw\n                this._currSize.width = this._origSize.width - tmpX;\n                this._currPos.x = this._origPos.x + tmpX;\n            }\n            this.checkBounds();\n            this.checkSize();\n            this.adjustByRatio();\n            this.doResize();\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.doResize = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var container = this.el.nativeElement;\n            if (!this._direction || this._direction.n || this._direction.s || this._aspectRatio) {\n                this.renderer.setStyle(container, 'height', this._currSize.height + 'px');\n            }\n            if (!this._direction || this._direction.w || this._direction.e || this._aspectRatio) {\n                this.renderer.setStyle(container, 'width', this._currSize.width + 'px');\n            }\n            this.renderer.setStyle(container, 'left', this._currPos.x + 'px');\n            this.renderer.setStyle(container, 'top', this._currPos.y + 'px');\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.adjustByRatio = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            if (this._aspectRatio && !this._adjusted) {\n                if (this._direction.e || this._direction.w) {\n                    /** @type {?} */\n                    var newHeight = Math.floor(this._currSize.width / this._aspectRatio);\n                    if (this._direction.n) {\n                        this._currPos.y += this._currSize.height - newHeight;\n                    }\n                    this._currSize.height = newHeight;\n                }\n                else {\n                    /** @type {?} */\n                    var newWidth = Math.floor(this._aspectRatio * this._currSize.height);\n                    if (this._direction.n) {\n                        this._currPos.x += this._currSize.width - newWidth;\n                    }\n                    this._currSize.width = newWidth;\n                }\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.checkBounds = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            if (this._containment) {\n                /** @type {?} */\n                var maxWidth = this._bounding.width - this._bounding.pr - this._bounding.deltaL - this._bounding.translateX - this._currPos.x;\n                /** @type {?} */\n                var maxHeight = this._bounding.height - this._bounding.pb - this._bounding.deltaT - this._bounding.translateY - this._currPos.y;\n                if (this._direction.n && (this._currPos.y + this._bounding.translateY < 0)) {\n                    this._currPos.y = -this._bounding.translateY;\n                    this._currSize.height = this._origSize.height + this._origPos.y + this._bounding.translateY;\n                }\n                if (this._direction.w && (this._currPos.x + this._bounding.translateX) < 0) {\n                    this._currPos.x = -this._bounding.translateX;\n                    this._currSize.width = this._origSize.width + this._origPos.x + this._bounding.translateX;\n                }\n                if (this._currSize.width > maxWidth) {\n                    this._currSize.width = maxWidth;\n                }\n                if (this._currSize.height > maxHeight) {\n                    this._currSize.height = maxHeight;\n                }\n                /**\n                 * Fix Issue: Additional check for aspect ratio\n                 * https://github.com/xieziyu/angular2-draggable/issues/132\n                 */\n                if (this._aspectRatio) {\n                    this._adjusted = false;\n                    if ((this._direction.w || this._direction.e) &&\n                        (this._currSize.width / this._aspectRatio) >= maxHeight) {\n                        /** @type {?} */\n                        var newWidth = Math.floor(maxHeight * this._aspectRatio);\n                        if (this._direction.w) {\n                            this._currPos.x += this._currSize.width - newWidth;\n                        }\n                        this._currSize.width = newWidth;\n                        this._currSize.height = maxHeight;\n                        this._adjusted = true;\n                    }\n                    if ((this._direction.n || this._direction.s) &&\n                        (this._currSize.height * this._aspectRatio) >= maxWidth) {\n                        /** @type {?} */\n                        var newHeight = Math.floor(maxWidth / this._aspectRatio);\n                        if (this._direction.n) {\n                            this._currPos.y += this._currSize.height - newHeight;\n                        }\n                        this._currSize.width = maxWidth;\n                        this._currSize.height = newHeight;\n                        this._adjusted = true;\n                    }\n                }\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.checkSize = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var minHeight = !this.rzMinHeight ? 1 : this.rzMinHeight;\n            /** @type {?} */\n            var minWidth = !this.rzMinWidth ? 1 : this.rzMinWidth;\n            if (this._currSize.height < minHeight) {\n                this._currSize.height = minHeight;\n                if (this._direction.n) {\n                    this._currPos.y = this._origPos.y + (this._origSize.height - minHeight);\n                }\n            }\n            if (this._currSize.width < minWidth) {\n                this._currSize.width = minWidth;\n                if (this._direction.w) {\n                    this._currPos.x = this._origPos.x + (this._origSize.width - minWidth);\n                }\n            }\n            if (this.rzMaxHeight && this._currSize.height > this.rzMaxHeight) {\n                this._currSize.height = this.rzMaxHeight;\n                if (this._direction.n) {\n                    this._currPos.y = this._origPos.y + (this._origSize.height - this.rzMaxHeight);\n                }\n            }\n            if (this.rzMaxWidth && this._currSize.width > this.rzMaxWidth) {\n                this._currSize.width = this.rzMaxWidth;\n                if (this._direction.w) {\n                    this._currPos.x = this._origPos.x + (this._origSize.width - this.rzMaxWidth);\n                }\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.getBounding = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var el = this._containment;\n            /** @type {?} */\n            var computed = window.getComputedStyle(el);\n            if (computed) {\n                /** @type {?} */\n                var p = computed.getPropertyValue('position');\n                /** @type {?} */\n                var nativeEl = window.getComputedStyle(this.el.nativeElement);\n                /** @type {?} */\n                var transforms = nativeEl.getPropertyValue('transform').replace(/[^-\\d,]/g, '').split(',');\n                this._bounding = {};\n                this._bounding.width = el.clientWidth;\n                this._bounding.height = el.clientHeight;\n                this._bounding.pr = parseInt(computed.getPropertyValue('padding-right'), 10);\n                this._bounding.pb = parseInt(computed.getPropertyValue('padding-bottom'), 10);\n                this._bounding.deltaL = this.el.nativeElement.offsetLeft - this._currPos.x;\n                this._bounding.deltaT = this.el.nativeElement.offsetTop - this._currPos.y;\n                if (transforms.length >= 6) {\n                    this._bounding.translateX = parseInt(transforms[4], 10);\n                    this._bounding.translateY = parseInt(transforms[5], 10);\n                }\n                else {\n                    this._bounding.translateX = 0;\n                    this._bounding.translateY = 0;\n                }\n                this._bounding.position = computed.getPropertyValue('position');\n                if (p === 'static') {\n                    this.renderer.setStyle(el, 'position', 'relative');\n                }\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.resetBounding = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            if (this._bounding && this._bounding.position === 'static') {\n                this.renderer.setStyle(this._containment, 'position', 'relative');\n            }\n            this._bounding = null;\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    AngularResizableDirective.prototype.getGridSize = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            // set default value:\n            this._gridSize = { x: 1, y: 1 };\n            if (this.rzGrid) {\n                if (typeof this.rzGrid === 'number') {\n                    this._gridSize = { x: this.rzGrid, y: this.rzGrid };\n                }\n                else if (Array.isArray(this.rzGrid)) {\n                    this._gridSize = { x: this.rzGrid[0], y: this.rzGrid[1] };\n                }\n            }\n        };\n    return AngularResizableDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar AngularDraggableModule = /** @class */ /*@__PURE__*/ (function () {\n    function AngularDraggableModule() {\n    }\n    return AngularDraggableModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nexport { AngularDraggableDirective, AngularResizableDirective, AngularDraggableModule, Position };\n//# sourceMappingURL=angular2-draggable.js.map\n",null]}